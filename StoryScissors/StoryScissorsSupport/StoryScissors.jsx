/** * StoryScissors.jsx * Javascript for InDesign CC, CS6, CS5.5, CS5 * Version date: 20200309 * * PURPOSE: * =========== * Split one or more stories at one or more selected paragraph styles or at the insertion pointer * * DISCLAIMER: * =========== * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE PRODUCER OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * * AUTHOR: * =========== * Andreas Imhof * ai@aiedv.ch * * This is free software! * License: GPL3 * * HISTORY: * 20200309 v2.0	New Lizense: GPL3 * 20151104 v1.3.0	Don't calc height of anchored objects if positioning is "user defined" */// we MUST run this in dedicated #targetengine "StoryScissors" because we have persistant variables and a palette//#target and #targetengine "StoryScissors" also must be set by non compiled caller program#target "InDesign"#targetengine "StoryScissors"var TargetApp = "InDesign",	INDminVersion = "7",	INDminVersionName = "CS5",	// run with CS5 7.x.x, CS6 8.x.x, CC 9.x.x	appVersion = app.version,	majorINDVersion = parseInt(appVersion.split(".")[0], 10);// check InDesign and versionif (app.name.toLowerCase().indexOf(TargetApp.toLowerCase()) < 0) {	// application name like 'Adobe InDesign'	alert("This script runs with " + TargetApp + " version " + INDminVersion + " ( " + INDminVersionName + " ) or newer.");	exit(0);}if (parseInt(majorINDVersion, 10) < parseInt(INDminVersion, 10)) {	// version string is like 8.0.2.413 for InDesign CS6	alert("This script needs " + TargetApp + " version " + INDminVersion + " ( " + INDminVersionName + " ) or newer.");	exit(0);}// persistent varsvar save_SS_settings = null,	// save/restore settings on external call	SS_external_call = false,	// flag if we are call by an external parent script	SS_returncode = 0,			// number of splitted frames returned by StoryScissors()	SS_exception = null,		// the exception on error	SS_isBusy = false,			// indicate that we are working (splitting columns or paras)		DO_NOTHING = 0,				// 1 = just load but do nothing	exports = {},				// exported functions from modules	folderSeparator = "/",	getScriptsPath = function () {		var fullpath = app.activeScript,			scriptFile = new File(fullpath);		return(scriptFile.path);	},	scriptPath = getScriptsPath();var StoryScissors = function(theSplitAtParaName,options) {	if (typeof(SS_settings) == 'undefined') {		var SS_settings = {			DEBUG: 0,					// show DEBUG alert messages			DEBUGlog: 0,				// > 0 = log messages to logger			DEBUGexceptions: 2,			// 1 = catch/alert exceptions to DEBUG, but continue after alert										// 2 = select the failing element (like a frame) and exit			DOCUMENT_recompose: 1,		// 1 = enable document recompose during processing. 0 = NO recompose			ENTIRE_DOCUMENT: 0,			// 1 = split all frames in document. 0 = current selection only			INCLUDE_LOCKED_LAYERS: 0,	// 1 = also unlock layers and split. 0 = ignore locked layers			INCLUDE_HIDDEN_LAYERS: 0,	// 1 = also process hidden layers and split. 0 = ignore locked layers			NO_MENU: 0,					// 1 = to not show a menu			SILENT: 0,					// addable flags										// 0 = default = show the paragraph selection menu and messages										// 1 = don't show progress messages			SILENT_COLSPLIT: 1,			// 1 = silently split multi columns frames			NO_COMLETION_MESSAGE: 0,	// 1 = do not show a completion message			frameAdjustMode: 0,			// how to adjust height story frame										// 0 = adjust new frame to last base line and descent (bottom border) of old frame plus para space after										// 1 = adjust to minimal height needed			frameAdjustAuto: 0,										// 0 = don't auto adjust by InDesign										// or one of										// FitOptions.CONTENT_TO_FRAME										// FitOptions.CENTER_CONTENT										// FitOptions.PROPORTIONALLY										// FitOptions.FRAME_TO_CONTENT										// FitOptions.FILL_PROPORTIONALLY										// FitOptions.APPLY_FRAME_FITTING_OPTIONS			splitAtParaName: [""],		// split at these array of paragraph styles			splitAtParaPos: 0,			// 0 = split at begin of this paragraph styles (default)										// 1 = split at end of this para			textWrapMode: -1,			// -1 = do not alter the text wrap mode of frames										// 0 = set to TextWrapModes.NONE			numParasSplitted: 0,		// num paras splitted per split run			totalParasSplitted: 0,		// num paras splitted in entire run			dlgw_location: [],			// dialog window last position			newframe_bottom_add_pix: 0.66	// points to ad to newframe bottom		}	}	var restore_settings = function(newset) {		for (var key in newset) SS_settings[key] = newset[key];	};	if (typeof(SS_wrk) == 'undefined') {		var SS_wrk = {			dlgw: null,				// main dialog palette			isopen: false,			activeDocumentID: null,	// track active document			activeDocumentName: ""		}	}	else {		SS_wrk.activeDocumentID = null;	// reset active document on load		SS_wrk.activeDocumentName = "";	}	var	Product = {			applicationName: "StoryScissors",			version: "02",			versionStr: "2.0",			// human readable version string			sub_version: "0",				// any free fixes: a sub-version			copyright: "\u00a9www.AiEDV.ch",			productShortcut: "SSid"		},		IDserialNumber = app.serialNumber,	// InDesign serial number - 20digits string		toDay = function () {			// get current date as YYYYMMDD			var now = new Date(),				year = "", month = "", day = "", today = "";			year = "" + now.getFullYear();			month = "" + (now.getMonth() + 1);			if (month.length < 2) month = "0" + month;			day = "" + now.getDate();			if (day.length < 2) day = "0" + day;			today = year + month + day;			return(today);		},		DEBUGselects = 0,					// show DEBUG messages on selected items		textframes = [],				// text frames of a story		allPageItems_in_textframes = false,	// is set to true if allPageItems was selected by 'checkMySelection()'		num_textframes = 0,				// flag to indicate, that we have text frames in the selection		numFrameCols = 1,				// tested num columns of text frames - may not be more than 1 col		i, s,							// internal working counter		myselections = null,			// internal selections store (from app.selection)		myselections_arefine = -1,		// internal flag to indicate that we have selected some splittable text frames		selectionIdx = 0,				// internal counter for selection index		go = false,		haveCallerScript = false,		numDocsOpen = app.documents.length,		hDs="0123456789ABCDEF",		d2hs = function (d) {	// decimal to hex conversion			var h = hDs.substr(d&15,1);			while (d>15) { d>>=4; h=hDs.substr(d&15,1)+h;}			if (h.length < 2) h = "0" + h;			return h;		},		hex_string = function(characters, count) {			var maxcnt = characters.count(),				hstr = "";			if (count && (maxcnt > count)) maxcnt = count;				//hstr += maxcnt + ": "  +count + ": ";			for (var i = maxcnt; i > 0; i--) {				if (typeof(characters[characters.count()-i].contents.charCodeAt) != 'undefined') {					for (var c = 0; c < characters[characters.count()-i].contents.length; c++) {						hstr += d2hs(characters[characters.count()-i].contents.charCodeAt(c)) + ", ";					}				}				else {						hstr += d2hs(characters[characters.count()-i].contents) + ", ";				}			}			return(hstr);		},		hex_array = function(characters, count) {			var maxcnt = characters.count(),				hexarr = [],				c;			for (var i = maxcnt; i > 0; i--) {				if (typeof(characters[characters.count()-i].contents.charCodeAt) != 'undefined') {					for (c = 0; c < characters[characters.count()-i].contents.length; c++) {						hexarr[hexarr.length] = d2hs(characters[characters.count()-i].contents.charCodeAt(c));					}				}				else {						hexarr[hexarr.length] = d2hs(characters[characters.count()-i].contents);				}			}			return(hexarr);		},		text_string = function(characters, count) {			var maxcnt = characters.count(),				hstr = "";			if (maxcnt > count) maxcnt = count;				hstr += maxcnt + ": "  +count + ": ";			for (var i = maxcnt; i > 0; i--) {				hstr += characters[characters.count()-i].contents;			}			return(hstr);		},				// calculate the frame height needed for the text that will be cut into the new frame		// endBaseline - firstBaseline + firstLineAscent + endLineDescent		// DEBUGGING ONLY!!!		calcCutoffHeightNeeded = function() {							var	underlineOffset = app.selection[0].paragraphs[0].lines[0].underlineOffset;				if (underlineOffset == -9999) underlineOffset = (app.selection[0].paragraphs[0].pointSize / 9.52307693);				var firstbaseline2top_leading = app.selection[0].paragraphs[0].baseline - app.selection[0].parentTextFrames[0].geometricBounds[0];	// baseline -boxtop				alert(	"Main box: " + app.selection[0].parentTextFrames[0]						+ "\nframe top: " + app.selection[0].parentTextFrames[0].geometricBounds[0]						+ "\nframe bottom: " + app.selection[0].parentTextFrames[0].geometricBounds[2]						+ "\nframe insetSpacing: " + app.selection[0].parentTextFrames[0].textFramePreferences.insetSpacing						+ "\nframe strokeWeight: " + app.selection[0].parentTextFrames[0].strokeWeight						+ "\nframe strokeAlignment: " + app.selection[0].parentTextFrames[0].strokeAlignment						+ "\nframe firstline offset enumarator: " + app.selection[0].parentTextFrames[0].textFramePreferences.firstBaselineOffset						+ "\nnum paras: " + app.selection[0].parentTextFrames[0].paragraphs.length						+ "\n\nfirst line to top box leading: " + firstbaseline2top_leading						+ "\ninsertion pointer ascent: " + app.selection[0].paragraphs[0].lines[0].ascent						+ "\ninsertion pointer baseline: " + app.selection[0].paragraphs[0].baseline						+ "\ninsertion pointer descent: " + app.selection[0].paragraphs[0].descent						+ "\ninsertion pointer underline offset: " + underlineOffset						+ "\ninsertion pointer font size: " + app.selection[0].paragraphs[0].pointSize						+ "\ninsertion pointer leading: " + app.selection[0].paragraphs[0].leading						+ "\nlast para baseline: " + app.selection[0].parentTextFrames[0].paragraphs.lastItem().baseline						+ "\nlast para endBaseline: " + app.selection[0].parentTextFrames[0].paragraphs.lastItem().endBaseline						+ "\nlast line descent: " + app.selection[0].parentTextFrames[0].paragraphs.lastItem().lines.lastItem().descent						+ "\n\nheight needed for selection to end: " + (	app.selection[0].parentTextFrames[0].paragraphs.lastItem().endBaseline					// last line descent																		- app.selection[0].paragraphs[0].baseline												// selected line baseline																		+ firstbaseline2top_leading																		+ app.selection[0].parentTextFrames[0].paragraphs.lastItem().lines.lastItem().descent	// last line descent																		)						);						var frameheight = app.selection[0].parentTextFrames[0].paragraphs.lastItem().endBaseline					// last line descent								- app.selection[0].paragraphs[0].baseline												// selected line baseline								+ app.selection[0].paragraphs[0].lines[0].ascent										// selected line ascent								+ app.selection[0].parentTextFrames[0].paragraphs.lastItem().lines.lastItem().descent;	// last line descent			return(frameheight);		},		// security function: make sure the box does not have overset text		unOverflowBox = function(frame, caller) {			var cnt = 0;	// security break;			if (!frame.overflows) return;			//alert("unOverflowBox CALLER: " + (typeof(caller) != 'undefined' ? caller : ""));			while(frame.overflows) {				frame.geometricBounds = [frame.geometricBounds[0], frame.geometricBounds[1], frame.geometricBounds[2] + 0.2, frame.geometricBounds[3]];	// [y1, x1, y2, x2]				//cnt++;				//if (cnt > 1000) break;			}		},		// calc height of highest anchored object		// = amount over baseline+ascent (from calcFrameTop())		calcAnchoredLineHeight = function(pageitems, thepara, noascent) {			var height = 0,				anchorSpaceAbove = 0,				anchorYoffset = 0,				h, i;			//alert("calcAnchoredLineHeight pageitems: " + pageitems);			for (i = 0; i < pageitems.length; i++) {				if (pageitems[i].anchoredObjectSettings.anchoredPosition == AnchorPosition.ANCHORED) continue;	// ignore user defined position				anchorSpaceAbove = 0;				anchorYoffset = 0;				try {					anchorSpaceAbove = pageitems[i].anchoredObjectSettings.anchorSpaceAbove;					anchorYoffset = pageitems[i].anchoredObjectSettings.anchorYoffset;				}				catch(ex){}				/*				alert("num pageItems: " + pageitems.length + " pageItem #" + i + " : " + pageitems[i].constructor.name					+ "\nh: " + (pageitems[i].geometricBounds[2] - pageitems[i].geometricBounds[0])		// y2 -y1					+ "\nsingle Stroke weight: " + getFrameStrokeWeight(pageitems[i])					+ "\nStroke weight: " + (2*getFrameStrokeWeight(pageitems[i]))					+ "\nanchorSpaceAbove: " + anchorSpaceAbove					+ "\nanchorYoffset: " + anchorYoffset					+ "\n\nthepara.lines[0].baseline: " + thepara.lines[0].baseline					+ "\nthepara.lines[0].ascent: " + thepara.lines[0].ascent					+ "\nthepara.lines[0].descent: " + thepara.lines[0].descent					+ "\nthepara.lines[0].leading: " + thepara.lines[0].leading					);				*/				try {					h = pageitems[i].geometricBounds[2] - pageitems[i].geometricBounds[0];		// y2 -y1					h += (2*getFrameStrokeWeight(pageitems[i]));					h += pageitems[i].anchoredObjectSettings.anchorSpaceAbove;					h += pageitems[i].anchoredObjectSettings.anchorYoffset;					//h += thepara.lines[0].leading;	/// do NOT add!! (not sure if this is OK for all cases					if ((typeof(noascent) != 'undefined') && (noascent === true)) h -= thepara.lines[0].ascent;	// caller already takes this in account, so we subtract it here					if (h > height) height = h;				} catch(e){ continue; }			}			return(height);		},				// calculate the top position of frame frame height needed for the text that will be cut into the new frame		// firstBaseline - firstLineAscent							// this may fail, due to 							// a) text in overflow							// b) overlapping boxes, both set to text wrap runaround and therefore text will overflow suddenly		calcFrameTop = function(thepara) {			//alert("calcFrameTop thepara.isValid: " + thepara.isValid);			unOverflowBox(thepara.lines[0].parentTextFrames[0], "calcFrameTop 1");			var anchorheight = calcAnchoredLineHeight(thepara.lines[0].allPageItems, thepara, true),				frametop = thepara.baseline								// para first line baseline							- thepara.lines[0].ascent					// para first line ascent							- getFrameInsetSpacing(thepara.lines[0].parentTextFrames[0],0)							- getFrameStrokeWeight(thepara.lines[0].parentTextFrames[0])							- anchorheight;			// a line may contain anchored object which are much higher			/*			alert("thepara.baseline: " + thepara.baseline 					+ "\nthepara.ascent: " + thepara.ascent					+ "\nthepara.lines[0].ascent: " + thepara.lines[0].ascent					+ "\nthepara.lines[0].characters[0].ascent: " + thepara.lines[0].characters[0].ascent					+ "\ncharacters[0]: " + thepara.lines[0].characters[0].contents.charCodeAt(0) + " : " + hex_string(thepara.lines[0].characters,3)					+ "\nline heght anchored objects: " + anchorheight					+ "\n\nframetop: " + frametop					);			*/			return(frametop);		},		// calculate the bottom position of frame		// endBaseline + descent							// this may fail, due to 							// a) text in overflow		calcFrameBottom = function(thepara) {			var framebottom;			// this may fail, if text is in overflow - catch exeption			//alert(thepara.endBaseline);			framebottom = thepara.endBaseline								// para last line baseline							+ thepara.descent							+ getFrameInsetSpacing(thepara.parentTextFrames[0],2);			// ad para spaceAfter, but only if frame has alignment top			try {				//alert (thepara.parentTextFrames[0].textFramePreferences.verticalJustification == VerticalJustification.TOP_ALIGN);				if (thepara.parentTextFrames[0].textFramePreferences.verticalJustification == VerticalJustification.TOP_ALIGN) {					if (SS_settings.frameAdjustMode <= 0) framebottom += thepara.spaceAfter;				}			}			catch(ex){}			return(framebottom);		},		// get frame inset spacings		getFrameInsetSpacing = function(theframe, which) {				// which for [top inset, left inset, bottom inset, right inset]																		//				0			1			2			3			if (theframe == null) return(0);			var inset = theframe.textFramePreferences.insetSpacing;			//alert(inset + "\n" + typeof(inset));			if (typeof(inset) == 'object') return(inset[which]);			return(inset);		},		getFrameStrokeWeight = function(theframe) {			try {				if (typeof(theframe.strokeWeight) === undefined) return 0;				}			catch(ex) {	// strokeWeight not supported for this object				return 0;			}			if (theframe == null) return(0);			var weight = parseFloat(theframe.strokeWeight),				align = theframe.strokeAlignment;				// IMPORTANT on strokeWeight:				// strokeWeight might report 1pt BUT IT ACTUALLY IS 0pt !!				// Happens when working with old CS3 (4?) documents in new CS versions				// Also, the objects style palette reports an override of stroke weight - but is not				// So far, no way found to work around this.				//alert("weight: " + theframe.strokeWeight + "\ntypeof weight: " + typeof(weight) + "\nalign: " + align + "\nstrokeColor: " + theframe.strokeColor.name + "\n\n+++ from Object Style: '" + theframe.appliedObjectStyle.name + "'\n" + list_object(theframe.appliedObjectStyle,"stroke"));			switch (align) {				case StrokeAlignment.OUTSIDE_ALIGNMENT:	// 1936998735 = 'stAO'					return(0);				case StrokeAlignment.CENTER_ALIGNMENT:	// 1936998723 = 'stAC'					return(weight/2);				case StrokeAlignment.INSIDE_ALIGNMENT:	// 1936998729 = 'stAI'					return(weight);			}			return(0);		},		// minify all frames in a chain		// make frames as small as possible - also on 'empty' top/bottom space - runaround		minifyFrame = function(theframe, includechain) {			if (!theframe || (!theframe.isValid)) return;			var newTop,				newBottom;			try {				unOverflowBox(theframe, "minifyFrame 1");				//alert("minifyFrame\nframe old top: " + theframe.geometricBounds[0] + " new top: " + newTop + "\nframe old bottom: " + theframe.geometricBounds[2] + " new bottom: " + newBottom + "\n\nheight needed: " + (newBottom - newTop));				if (theframe.lines[0].isValid) newTop = calcFrameTop(theframe.lines[0]);				else newTop = theframe.geometricBounds[0];				// get bottom				newBottom = theframe.geometricBounds[2];				if (theframe.textFramePreferences.verticalJustification != VerticalJustification.TOP_ALIGN) {					if (theframe.lines.lastItem().isValid) newBottom = calcFrameBottom(theframe.lines.lastItem());				}				//alert("minifyFrame\nframe old top: " + theframe.geometricBounds[0] + " new top: " + newTop + "\nframe old bottom: " + theframe.geometricBounds[2] + " new bottom: " + newBottom + "\n\nheight needed: " + (newBottom - newTop));				theframe.geometricBounds = [newTop, theframe.geometricBounds[1], newBottom, theframe.geometricBounds[3]];				unOverflowBox(theframe, "minifyFrame 2");				if (includechain && theframe.nextTextFrame) minifyFrame(theframe.nextTextFrame);			} catch(ex) {				// enable this to find the cause of this exception				debug_exception("Exception in function 'minifyFrame':\n", ex, theframe);			}			return;		},		// split at a paragraph		setSplitAtParaName = function(paraname) {			var arr = [], i, 				myparaname = paraname;			//alert("setSplitAtParaName\nparaname.constructor.name: " + paraname.constructor.name + "\nparaname: " + paraname);			switch (paraname.constructor.name) {				case 'Array':	// an array of ListItem					if (myparaname.length > 0) {						if (myparaname[0].constructor.name == "ListItem") {							//alert("myparaname: " + myparaname[0].constructor.name);							for (i = 0; i < myparaname.length; i++) {								arr[arr.length] = myparaname[i].text;							}						}						else {							//alert("myparaname: " + myparaname[0].constructor.name);							for (i = 0; i < myparaname.length; i++) {								arr[arr.length] = myparaname[i];							}						}					}					//alert("setSplitAtParaName paraname: "+ paraname + "\n" + list_object(myparaname) + "\n" + paraname.constructor.name + "\n\narr: " + arr + "\n\narr[0]: " + arr[0]);					return(arr);					break;				case 'Object':					return(myparaname);					break;				case 'undefined':				case 'null':					return([""]);					break;				case 'String':					if (myparaname == "") return([""]);					if (myparaname.indexOf(",") < 0) return([myparaname]);					return(myparaname.split(","));					break;			}			return([""]);		},		paraMatchName = function(paraname) {			var pn = 0;			if (SS_settings.splitAtParaName[0] == "*") return(true);	// wildcard 'match all'					//alert("paraMatchName for: " + paraname + "\nin: " + SS_settings.splitAtParaName + "\nlength: " + SS_settings.splitAtParaName.length + "\n[0]: " + SS_settings.splitAtParaName[0] + "\ntypeof: " + SS_settings.splitAtParaName.join(","));			for (pn = 0; pn < SS_settings.splitAtParaName.length; pn++) {				// JUST FOR TESTING: if (paraname.indexOf(SS_settings.splitAtParaName[pn]) >= 0) return(true);					//alert("paraMatchName\nparaname: '" + paraname + "'=='" + SS_settings.splitAtParaName[pn] + "'\n" + (paraname == SS_settings.splitAtParaName[pn]));				if (paraname == SS_settings.splitAtParaName[pn]) return(true);			}			return(false);		},		has_story_paraMatchName = function(textframe) {			var paramatch = false, p;			if ( !textframe.isValid ) return(false);			if ( !textframe.startTextFrame.isValid ) return(false);			if ( !textframe.startTextFrame.parentStory.isValid ) return(false);			if (textframe.startTextFrame.parentStory.paragraphs.length < 2) return(false);	// we need at least 2 paras to split a frame			//alert("has_story_paraMatchName SS_settings.splitAtParaName: " + SS_settings.splitAtParaName + "\n[0]: " + SS_settings.splitAtParaName[0]);			for (p = textframe.startTextFrame.parentStory.paragraphs.length -1; p >= 0; p--) {				paramatch = paraMatchName(textframe.startTextFrame.parentStory.paragraphs[p].appliedParagraphStyle.name);				if (paramatch) {					//alert("has_story_paraMatchName for: " + textframe.startTextFrame.parentStory.paragraphs[p].appliedParagraphStyle.name);					return(true);				}			}			//alert("has_story_paraMatchName no match for: " + textframe.startTextFrame.parentStory.paragraphs[p].appliedParagraphStyle.name + "\n\n" + SS_settings.splitAtParaName + "\n in " + textframe.startTextFrame.parentStory.paragraphs.length + " paragraphs");			return(paramatch);		},		debug_exception = function(mess, ex, selection) {			// catch/alert exceptions to DEBUG			if (SS_settings.DEBUGexceptions <= 0) return(false);			alert(mess + "Line: " + ex.line + "\n" + ex.message);			if (SS_settings.DEBUGexceptions > 1) {				if ((typeof(selection) != 'undefined') && (selection != null)) try { app.select(selection); } catch(excp) {}				exit(0);			}			return(true);		},		messageWindow = null,		messageCreate = function (mess) {			try {				messageWindow = new Window('window', 'Story Scissors', undefined, {maximizeButton:false, minimizeButton:false,  independent:true, borderless:true});			} catch(e){}			try {				messageWindow.orientation = 'row';				messageWindow.margins = [50,30,50,30];				messageWindow.messtext = messageWindow.add('statictext', undefined, mess, {multiline:true});				messageWindow.messtext.maximumSize = [400,200];				messageWindow.messtext.preferredSize = [300,60];			} catch(e){}			try {				messageWindow.show();			} catch(e){}			return;		},		messageClose = function () {			var oldinteraction = app.scriptPreferences.userInteractionLevel;			app.scriptPreferences.userInteractionLevel = UserInteractionLevels.INTERACT_WITH_ALL;			if (/*inpalette && */SS_wrk.dlgw && SS_wrk.dlgw.rightGroup.hint) {				SS_wrk.dlgw.rightGroup.hint.text = "";			}			if (messageWindow != null) {				try {					messageWindow.close();					messageWindow = null;				} catch(e){}			}			if (oldinteraction != app.scriptPreferences.userInteractionLevel) app.scriptPreferences.userInteractionLevel = oldinteraction;		},		message = function (mess,closeAfter,force, inpalette) {			var oldredraw, oldinteraction;			if ( !(force === true) && (SS_settings.SILENT > 0) ) return;			if (mess == null) {				messageClose();				return;			}			oldredraw = app.scriptPreferences.enableRedraw;			app.scriptPreferences.enableRedraw = true;			oldinteraction = app.scriptPreferences.userInteractionLevel;			app.scriptPreferences.userInteractionLevel = UserInteractionLevels.INTERACT_WITH_ALL;			try {				if (/*inpalette && */SS_wrk.dlgw && SS_wrk.dlgw.rightGroup.hint) {				//if (false && SS_wrk.dlgw && SS_wrk.dlgw.rightGroup.hint) {					SS_wrk.dlgw.rightGroup.hint.text = mess;					SS_wrk.dlgw.show();	// in unknown cases, this seems to help to update messages better				}				else {					if (messageWindow == null) messageCreate(mess);					else {						try {							//messageWindow.hide();	// ugly way to force update during prcessing							messageWindow.messtext.text = mess;							//messageWindow.show();						} catch(ex){}					}					if (closeAfter) {						$.sleep(closeAfter);						messageClose();					}				}			} catch(e){				//alert(e);			}			if (oldinteraction != app.scriptPreferences.userInteractionLevel) app.scriptPreferences.userInteractionLevel = oldinteraction;			if (oldredraw != app.scriptPreferences.enableRedraw) app.scriptPreferences.enableRedraw = oldredraw;			return;		},		idle_messageMess = {mess:"", close:3000},		idle_messageTask = null,		idle_messageHdl = function(ev) {			//alert("idle_messageHdl: " + idle_messageMess.mess);			message(idle_messageMess.mess,idle_messageMess.close, idle_messageMess.force);		    if ( idle_messageTask.isValid ) {				idle_messageTask.removeEventListener( IdleEvent.ON_IDLE, idle_messageHdl, false );				idle_messageTask.remove ();				idle_messageTask = null;		    	//alert("idle message removed");		    }		},		idle_message = function(messObj) {			//alert("idle_message: " + messObj.mess);			idle_messageMess = messObj;	// like {mess:"blahblah", close:3000}			if (idle_messageTask == null) idle_messageTask = app.idleTasks.add({name:"StoryScissorsIdleMessage", sleep:1});			idle_messageTask.addEventListener(IdleEvent.ON_IDLE, idle_messageHdl,false);		},		list_object = function(obj, which, objname, nofuncs) {			if (typeof(obj) == 'undefined') return('undefined');			if (typeof(obj) == null) return('null');			var str = "",				numprops = 0, n = 0;			if ((typeof(objname) != 'undefined') && (objname != '')) str += objname + " = {\n";			for (var key in obj) numprops++;			for (var key in obj) {				if ((typeof(which) != 'undefined') && (which != '') && (key.toLowerCase().indexOf(which) < 0)) continue;				try {					if ( (obj[key].constructor.name == 'Function') && (typeof(nofuncs) != 'undefined') && (nofuncs == true) ) continue;					str += key + ":";					//alert (key + ": " + obj[key] + ": " + obj[key].constructor.name);					switch (obj[key].constructor.name) {						case 'Array':							var arr = obj[key];							str += "[";							for (var i = 0; i < arr.length; i++) {								str += (typeof(arr[i]) == 'string' ? "\"" : "") + arr[i] + (typeof(arr[i]) == 'string' ? "\"" : "");								if (i < (arr.length-1)) str += ",";							}							str += "]";							break;						case 'String':							 str += "\"" + obj[key] + "\"";							break;						case 'Point':							 str += "[" + obj[key][0] + "," + obj[key][1] + "]";							break;						case 'Function':							 str += "[" + obj[key][0] + "," + obj[key][1] + "]";							break;						default:	// Number							 str += obj[key];							 break;					}				} catch(ex){					str += "\"not valid in this state\"";				}				n++;				if (n < numprops) str += ",\n";				else str += "\n";			}			if ((typeof(objname) != 'undefined') && (objname != '')) str += "}\n";			return(str);		},		origHorizontalMeasurementUnits,		origVerticalMeasurementUnits,		origStrokeMeasurementUnits,		setMeasurementUnitsPoints = function() {			origHorizontalMeasurementUnits = app.activeDocument.viewPreferences.horizontalMeasurementUnits;			origVerticalMeasurementUnits = app.activeDocument.viewPreferences.verticalMeasurementUnits;			origStrokeMeasurementUnits = app.activeDocument.viewPreferences.strokeMeasurementUnits;			app.activeDocument.viewPreferences.horizontalMeasurementUnits = MeasurementUnits.POINTS;			app.activeDocument.viewPreferences.verticalMeasurementUnits = MeasurementUnits.POINTS;			app.activeDocument.viewPreferences.strokeMeasurementUnits = MeasurementUnits.POINTS;		},		resetMeasurementUnits = function() {			app.activeDocument.viewPreferences.horizontalMeasurementUnits = origHorizontalMeasurementUnits;			app.activeDocument.viewPreferences.verticalMeasurementUnits = origVerticalMeasurementUnits;			app.activeDocument.viewPreferences.strokeMeasurementUnits = origStrokeMeasurementUnits;		},		get_chainFrames = function(frame) {			var tf = frame.startTextFrame, is_in = false, i;			while (tf) {				is_in = false;				for (i = 0; i < textframes.length; i++) {					if (textframes[i].id == tf.id) {						is_in = true;						break;					}				}				if (!is_in) textframes[textframes.length] = tf;				tf = tf.nextTextFrame;			}			return;		},		enough_textframes = 999999999;	// just say: ' we do have text frame(s)		countTextFrames = function (selection, get_short) {			var txtframecnt = 0, groups, i, parentFrames;			//alert("countTextFrames constructor: " + selection.constructor.name);			if (selection.constructor.name == 'Group') {	// group selected				// check if the group contains Text frames				try {					if (!selection.isValid) return(txtframecnt);				} catch(ex) { return(txtframecnt); }				//alert("countTextFrames isValid: " + selection.isValid + "\n" + selection.textFrames.length + "\n" + list_object(selection.textFrames));				txtframecnt += selection.textFrames.length;				if (get_short && (txtframecnt > 0)) {					txtframecnt = enough_textframes;				}				else {					for (i = 0; i < selection.textFrames.length; i++) textframes[textframes.length] = selection.textFrames[i];					// check if the group contains more groups					groups = selection.groups;					for ( i = 0; i < groups.length; i++) {						txtframecnt += countTextFrames(groups[i], get_short);						if (get_short && (txtframecnt > 0)) { txtframecnt = enough_textframes; break; }					}				}			}			else if (selection.constructor.name == 'TextFrame') {						txtframecnt++;						if (!allPageItems_in_textframes && !get_short && (selection.previousTextFrame || selection.nextTextFrame)) get_chainFrames(selection);						else textframes[textframes.length] = selection;						if (get_short && (txtframecnt > 0)) txtframecnt = enough_textframes;					} else {						if (selection instanceof InsertionPoint || selection instanceof Character || selection instanceof Text || selection instanceof TextStyleRange) {							try {	// tables and cells are not allowed								//alert(selection.constructor.name + "\n" + selection.parent.constructor.name + "\n" + typeof(selection.parent.textContainers));								if (typeof(selection.parent.textContainers) != 'undefined') {									parentFrames = selection.parent.textContainers;	// get frames of story									//alert("parent: " + selection.parent.constructor.name + "\nsparentFrames.length: " + parentFrames.length);									for ( i = 0; i < parentFrames.length; i++) {										txtframecnt++;										textframes[textframes.length] = parentFrames[i];										if ((get_short == true) && (txtframecnt > 0)) { txtframecnt = enough_textframes; break; }									}								}							} catch(ex) {								//alert("selection: " + selection + "\nparent: " + selection.parent.constructor.name + "\n typeof textContainers: " + typeof(selection.parent.textContainers) + "\n\n" + ex.message);							}						}					}			//alert("countTextFrames short: " + get_short + "\nname: " + selection.constructor.name + "\ntxtframecnt: " + txtframecnt);			return(txtframecnt);		},		countAllTextFrames = function (get_short) {			var s;			num_textframes = 0;			textframes = [];			// count and store all text frames in the selection			if (!get_short && (SS_settings.SILENT <= 0)) message(Product.applicationName + "\nCounting text frames...");			for (s = 0; s < myselections.length; s++) {				//alert("myselections constructor: " + myselections[s].constructor.name);				num_textframes += countTextFrames(myselections[s], get_short);				if (get_short && (num_textframes > 0)) break;			}			//alert("countTextFrames short: " + get_short + "\nSelection contains " + num_textframes + " text frames\n" + textframes.length);			if (!get_short && (SS_settings.SILENT <= 0)) messageClose();			return(num_textframes);		},		noSplit = function (obj) {			try {				if (   (obj.label.indexOf("*nosplit*") >= 0)					|| (obj.parent.label.indexOf("*nosplit*") >= 0)					|| (obj.parent.parent.label.indexOf("*nosplit*") >= 0)					|| (obj.parent.parent.parent.label.indexOf("*nosplit*") >= 0)					) return(true);			} catch(ex){}			return(false);		},		collectGroupTextFrames = function (group) {			var s;			for (s = 0; s < group.allPageItems.length; s++) {				switch (group.allPageItems[s].constructor.name) {					case "TextFrame":						alert("collectGroupTextFrames - contains a TextFrame");						myselections[myselections.length] = group.allPageItems[s];						break;					case "Group":						alert("collectGroupTextFrames - contains a Group");						myselections[myselections.length] = group.allPageItems[s];						//collectGroupTextFrames(group.allPageItems[s]);						break;				}			}		},		groupmembers_store = [],		groupmembers_parent = null,		groupmembers_store_IDs = function (thegroup) {			//alert("groupmembers_store_IDs");			groupmembers_parent = thegroup.parent;	// this will be the new items owner after ungroup			groupmembers_store = [];			for (var i = 0; i < thegroup.allPageItems.length; i++) groupmembers_store[groupmembers_store.length] = thegroup.allPageItems[i].id;	// get all IDs as array			//alert("groupmembers_store: " + groupmembers_store);		},		groupmembers_textframes_item_replace = function (pageitem) {			for (var i = 0; i < textframes.length; i++) {				if (textframes[i].id == pageitem.id) textframes[i] = pageitem;				return;			}		},		groupmembers_restore = function () {			var pageitems, i, t;			pageitems = groupmembers_parent.allPageItems;	// all items owned by new owner			for (var i = 0; i < groupmembers_store.length; i++) {				for (var t = 0; t < pageitems.length; t++) {					if (groupmembers_store[i] == pageitems[t].id) groupmembers_textframes_item_replace(pageitems[t]);				}			}		},		groupmembers_inherit_textwrap = function (thegroup) {			if (thegroup.textWrapPreferences.textWrapMode == TextWrapModes.NONE) return;			//alert("groupmembers_inherit_textwrap");			for (var i = 0; i < thegroup.allPageItems.length; i++) {				//alert("item in group: " + thegroup.allPageItems[i].constructor.name + "\nparent: " + thegroup.allPageItems[i].parent.constructor.name + "\nparent.parent: " + thegroup.allPageItems[i].parent.parent.constructor.name);				// skip anchored objects				if (   (thegroup.allPageItems[i].parent.constructor.name == 'Character')					|| (thegroup.allPageItems[i].parent.parent.constructor.name == 'Character')					|| (thegroup.allPageItems[i].parent.parent.parent.constructor.name == 'Character')					) continue;				thegroup.allPageItems[i].textWrapPreferences.textWrapMode = thegroup.textWrapPreferences.textWrapMode;	// inherit text wrap mode to to group members				thegroup.allPageItems[i].textWrapPreferences.textWrapOffset = thegroup.textWrapPreferences.textWrapOffset;				thegroup.allPageItems[i].textWrapPreferences.textWrapSide = thegroup.textWrapPreferences.textWrapSide;			}			//alert("groupmembers_store: " + groupmembers_store);		},		// totally ungroup an object		ungroup = function (obj) {			var theobj = obj, have_ungrouped = false, did_ungroup = false, i;			if (!obj || !obj.isValid) return(false);			while (theobj.parent.constructor.name == 'Group') {				groupmembers_store_IDs(theobj.parent);	// store the group's members				//alert("ungrouping: " + theobj.constructor.name + " id: " + theobj.id);				try { theobj.parent.locked = false; } catch(ex) {};				try {					if (SS_settings.textWrapMode < 0) groupmembers_inherit_textwrap(theobj.parent);					theobj.parent.ungroup();				}				catch(ex) {					// a group may be pasted into an image rectangle and therefor may not be ungrouped					return(false);					alert("theobj.parent: " + theobj.parent.constructor.name + "\ntheobj.parent.parent: " + theobj.parent.parent.constructor.name);					debug_exception("Exception in function 'ungroup':\n", ex, theobj.parent);				};				have_ungrouped = true;				// now we have to make the textframes valid again				groupmembers_restore();			}			return(have_ungrouped);		},		getPageItemInGroup = function(group, itemID) {			var gi;			for (gi = 0; gi < group.textFrames.length; gi++) {				if (group.textFrames[gi].id == itemID) return(group.textFrames[gi]);			}			return(null);		},				getPageItem = function(obj) {			var itm, parent = obj.parent, pageitem;	// Spread or Group			//alert("obj.constructor.name: " + obj.constructor.name + "\nobj.id: " + obj.id + "\nparent: " + parent + "\nparent.pageItems.length: " + parent.pageItems.length);			if ( parent.constructor.name == 'Group') {				pageitem = getPageItemInGroup(parent, obj.id);				//alert("getPageItemInGroup: " + pageitem);				return(pageitem);			}			for ( itm = 0; itm < parent.pageItems.length; itm++) {				//alert("obj type: " + parent.pageItems[itm].constructor.name + "\nparent.pageItems[" + itm + " ]: " + parent.pageItems[itm].id + "\nparentPage index: " + parent.pageItems[itm].index);				if (parent.pageItems[itm].id == obj.id) return(parent.pageItems[itm]);			}			return(null);		},		getParentSpread = function(obj) {			var parent = obj.parent, parentname = "", p = 0;	// find parent 'Spread' or 'Layer'			//var tree = "";	// tree debug only			while (parent) {				parentname = parent.constructor.name;				//tree += parentname + "\n";				if (parentname == 'Document') {					parent = null;					break;				}				if ( (parentname == 'Spread') || (parentname == 'Layer') ) break;				p++;				if (p > 15) {	// security break					parent = null;					break;				}				parent = parent.parent;			}			//alert(tree);			return(parent);		},		getParentTextFrame = function(obj) {			var parent = obj.parent, parentname = "", p = 0;	// find parent 'Spread' or 'Layer'			var tree = "";	// tree debug only			while (parent) {				parentname = parent.constructor.name;				//tree += parentname + "\n";				if (parentname == 'Document') {					parent = null;					break;				}				if ( parentname == 'TextFrame' ) break;				if ( parentname == 'Story' ) {					parent = parent.textContainers[0];					break;				}				p++;				if (p > 15) {	// security break					parent = null;					break;				}				parent = parent.parent;			}			//alert(tree);			return(parent);		},		is_inSelectionList = function(obj) {			for (var i = 0; i < myselections.length; i++) {				if (myselections[i] == obj) return(true);			}			return(false);		},		recompose_document = function() {			if (SS_settings.DOCUMENT_recompose <= 0) return;			var originalRedraw = app.scriptPreferences.enableRedraw,				oldinteraction = app.scriptPreferences.userInteractionLevel;			app.scriptPreferences.enableRedraw = true;			app.scriptPreferences.userInteractionLevel = UserInteractionLevels.INTERACT_WITH_ALL;			app.activeDocument.recompose();			//app.activeDocument.windows[0].restore();			if (oldinteraction != app.scriptPreferences.userInteractionLevel) app.scriptPreferences.userInteractionLevel = oldinteraction;			if (originalRedraw != app.scriptPreferences.enableRedraw) app.scriptPreferences.enableRedraw = originalRedraw;		},		singleColumnsSplitter = function (textframe) {			//check_textframes_valid(true, true, "singleColumnsSplitter\n");			var created_newframes = [],				split_count = 0,				tf = textframe,				tf_prev_txframe = tf.previousTextFrame,	// store a previous frame in chain				tf_next_txframe = tf.nextTextFrame,		// store a next frame in chain				tfgroup = null,				tfgroupParent = null,				tfgroupMembers = null,				do_reselect = false,				tfbounds = tf.geometricBounds,				tfinsets = tf.textFramePreferences.insetSpacing,				columns = tf.textFramePreferences.textColumnCount,				colwidth = tf.textFramePreferences.textColumnFixedWidth,	//Math.round(tf.textFramePreferences.textColumnFixedWidth * 1000 ) / 1000,				colgutt = tf.textFramePreferences.textColumnGutter,			//Math.round(tf.textFramePreferences.textColumnGutter * 1000 ) / 1000,				insetamount =  tfinsets[1] + tfinsets[3],				strokewidth =  2 * getFrameStrokeWeight(tf),				framewidth = colwidth + insetamount + strokewidth,				shadowtf, 				prev_txframe = tf,							// store as previous frame in chain				newtf,				x1, y1, x2, y2,				frame_PageItem,				have_ungrouped = false,				i;			frame_PageItem = getPageItem(tf);				//alert("tf.id: " + tf.id + "\ntf.parent: " + tf.parent.constructor.name);			if ( tf.parent.constructor.name == 'Group') {				tfgroup = tf.parent;				// check if this group is in the selection list				/* currently we don't do this:					do_reselect = is_inSelectionList(tfgroup);					//alert("do_reselect: " + do_reselect);					tfgroupMembers = tfgroup.allPageItems;	// is array of PageItem				*/				tfgroupParent = getParentSpread(tfgroup);				//alert("have to deep-ungroup");				// is not enough! : tfgroup.ungroup();				have_ungrouped = ungroup(tf);				if (!have_ungrouped) return(0);			}			//alert("frame_PageItem tf: " + frame_PageItem + "\nwidth: " + (tfbounds[3] - tfbounds[1]) + "\ncolumns: " + columns + "\ngutter: " + colgutt + "\ncolwidth: " + colwidth + "\ninsetamount: " + insetamount + "\nstrokewidth: " + strokewidth + "\nframewidth: " + framewidth);			// make the multi columns frame a single column frame			y1 = tfbounds[0];			x1 = tfbounds[1];			y2 = tfbounds[2];			x2 = x1 + framewidth;	// we have to add the right box inset to have text at correct column width			tf.textFramePreferences.textColumnCount = 1;			tf.geometricBounds = [y1, x1, y2, x2];			// and unlink next textframe			if (tf_next_txframe) {				tf.nextTextFrame = null;	//NothingEnum.NOTHING;				tf_next_txframe.previousTextFrame = null;	//NothingEnum.NOTHING;			}			// duplicate to an empty shadow text frame			shadowtf = tf.duplicate();			try { shadowtf.locked = false; } catch(ex) {};			// unchain			shadowtf.nextTextFrame = null;	//NothingEnum.NOTHING;			shadowtf.previousTextFrame = null;	//NothingEnum.NOTHING;			// and delete contents			try {				shadowtf.parentStory.remove();			} catch(ex) {				// empty stories can nor be remove'd				// happens, when a multi columns frame in chain does not have any text ( like the last empty frame - not enough text )				/*				alert("Exception in function 'check_singleColumnsSplitter' while trying to remove non existant story:\nLine: " + ex.line + "\n" + ex.message);				app.select(tf);				exit(0);				*/			}			// create following single column frames			for (i = 1; i < columns; i++) {				// Calculate bounds for a new single column text frame				y1 = tfbounds[0];				x1 = tfbounds[1] + (i * (colwidth + colgutt));				y2 = tfbounds[2];				x2 = x1 + framewidth;						// duplicate our empty shadow frame to a new text frame				if (tfgroupParent) newtf = shadowtf.duplicate(tfgroupParent);				else newtf = shadowtf.duplicate();				created_newframes[created_newframes.length] = newtf;				split_count++;				// Size/Position like original column				newtf.geometricBounds = [y1, x1, y2, x2];				// bring into same group if tf is in a group				if (tfgroupMembers != null) {					tfgroupMembers.push(newtf);				}				// set sequence to AFTER (if possible)				if (frame_PageItem != null) {					try {						newtf.bringToFront(frame_PageItem);					} catch(ex) {						debug_exception("Exception in function 'singleColumnsSplitter' while bringToFront a frame:\n", ex, newtf);						/*						alert("bringToFront_frame_PageItem: " + frame_PageItem + "  : " + i + "\nnewtf.parent: " + newtf.parent + "\nframe_PageItem.parent: " + frame_PageItem.parent);						app.select(newtf);						app.select(frame_PageItem);						alert(frame_PageItem.anchoredObjectSettings);						exit(0);						*/					}				}				// store this pageItem				frame_PageItem = getPageItem(newtf),									// Link new frame to the previous frame				prev_txframe.nextTextFrame = newtf;						// store new text frame as previous frame				prev_txframe = newtf;			}			//if ( SS_settings.SILENT <= 0 ) message(Product.applicationName + "\nDONE splitting " + columns + " into single column frames.");			// Delete the shadow text frame			shadowtf.remove();			// relink the rest of chained boxes to the last created frame			if (tf_next_txframe) {				prev_txframe.nextTextFrame = tf_next_txframe;				//tf_next_txframe.previousTextFrame = prev_txframe;	// is automatically set by above command - setting: prev_txframe.nextTextFrame = tf_next_txframe;			}			// re-group			/* Do not re-group or TEST THE ENTIRE PROCESS!!!! I tell you!!			if (tfgroupMembers != null) {				var newgroup = tfgroupParent.groups.add(tfgroupMembers);				if (do_reselect) {					//newgroup.select(SelectionOptions.ADD_TO);					myselections[myselections.length] = newgroup;				}			}			*/			// add the new created frames to textframes			// we really have to do this, because original frames become invalid after ungroup			for (i = 0; i < created_newframes.length; i++) {				textframes[textframes.length] = created_newframes[i];			}			//check_textframes_valid(true, true, check_textframes_valid_report + "\n\n");			return(split_count);		},		// check if we have multi column textframes which must be splitted first		check_singleColumnsSplitter_count = 0,		check_singleColumnsSplitter = function (silent, doColSplit) {			// params may com as an array in 'silent'			if (silent.constructor.name == 'Array') {				if (silent.length > 1) var doColSplit = silent[1];				if (silent[0] === true) silent = true;				else silent = false;			}			var originalRedraw, originalPreflight, originalTool = app.toolBoxTools.currentTool, 				split_count,				storytextframes, havesplitted, haveparasplits,				alreadyAsked = silent,				doit = false, i, s,				message_shown = false;			originalPreflight = app.activeDocument.preflightOptions.preflightOff;			app.activeDocument.preflightOptions.preflightOff = true;						originalRedraw = app.scriptPreferences.enableRedraw;			app.scriptPreferences.enableRedraw = false;			check_singleColumnsSplitter_count = 0;			if ( SS_settings.SILENT_COLSPLIT > 0 ) alreadyAsked = true;			if ( SS_settings.SILENT <= 0 ) message(Product.applicationName + "\nChecking " + textframes.length + " text frames to split multi columns. Please wait...");			//check_textframes_valid(true, true, "check_singleColumnsSplitter\n");			for (i = 0; i < textframes.length; i++) {				if (ScriptUI.environment.keyboardState.ctrlKey && ScriptUI.environment.keyboardState.shiftKey) {					messageClose();					alert("User abort");					return(false);				}				try {					//alert("textframes.length: " + textframes.length + "\ntextframes[" + i + "]: " + textframes[i] +"\nisValid: " + textframes[i].isValid);					if (!textframes[i].isValid) continue;					// check layer (anchored objects are not on a layer)					try {						if (textframes[i].itemLayer.visible == false) {	// is visible?							if (SS_settings.INCLUDE_HIDDEN_LAYERS <= 0) continue;						}						if (textframes[i].itemLayer.locked == true) {	// is locked?							if (SS_settings.INCLUDE_LOCKED_LAYERS <= 0) continue;						}					} catch(ex) { continue; }					// check for *nosplit* label					if (noSplit(textframes[i])) continue;					if (textframes[i].parent instanceof Character) continue;	// this is an anchored textframe					if (textframes[i].previousTextFrame) continue;	// we check the parent story frame only (it IS in the list of textframes[] )					if (!textframes[i].parentStory) continue;					if (!textframes[i].parentStory.textContainers) continue;					if ( (SS_settings.SILENT <= 0)						&& (textframes.length > 50)						&& (i % 10 == 0)						) message(Product.applicationName + "\nChecking frame " + i + " of " + textframes.length + " text frames to split multi columns. Please wait...");					// check if this frame actually must be splitted to columns frames because we have to split paragraphs					// if no split paragraph names are given, we split columns					if (!(doColSplit === true) && (SS_settings.splitAtParaName[0] != "")) {						//if ( SS_settings.SILENT <= 0 ) message(Product.applicationName + "\nChecking frame " + i + " of " + textframes.length + " text frames for has_story_paraMatchName. Please wait...");						haveparasplits = has_story_paraMatchName(textframes[i])						if (!haveparasplits) continue;					}					setMeasurementUnitsPoints();					try {						storytextframes = textframes[i].parentStory.textContainers;						havesplitted = false;						//for (s = 0; s < storytextframes.length; s++) {						for (s = storytextframes.length-1; s >= 0; s--) {							//alert("cols: " + storytextframes[s].textFramePreferences.textColumnCount);							if (storytextframes[s].textFramePreferences.textColumnCount > 1) {									// just to step through frames - uncomment for DEBUG									//app.select(storytextframes[s]);								if (!alreadyAsked) {									alreadyAsked = true;									doit = confirm("Story Scissors\nMulti columns text frames must be converted to single column frames!\n\nShould I convert the multi columns text frames?");									if (!doit) return(false);								}								if (!message_shown && (SS_settings.SILENT <= 0) ) {									message(Product.applicationName + "\nSplitting multi column text frames. Please wait...");									message_shown = true;								}								split_count = singleColumnsSplitter(storytextframes[s]);								if (split_count > 0) {									check_singleColumnsSplitter_count += split_count;									havesplitted = true;								}							}						}					} catch(ex) {						// enable this to find the cause of this exception						debug_exception("Exception in function 'check_singleColumnsSplitter' while processing textContainers:\n", ex, textframes[i]);					}					resetMeasurementUnits();				} catch(ex) {					debug_exception("Exception in function 'check_singleColumnsSplitter':\n", ex, textframes[i]);				}			}						if (check_singleColumnsSplitter_count > 0) recompose_document();	// recompose if multi columns frames were splitted			app.scriptPreferences.enableRedraw = originalRedraw;			app.toolBoxTools.currentTool = originalTool;			app.activeDocument.preflightOptions.preflightOff = originalPreflight;			// clean up myselections			clean_myselections();			if (message_shown || (SS_settings.SILENT <= 0)) messageClose();			if ((typeof(doColSplit) != 'undefined') && (doColSplit == true) && (SS_settings.SILENT <= 0)) message(Product.applicationName + "\n" + check_singleColumnsSplitter_count + " columns splitted.");						return(true);		},		clean_myselections = function() {			for (var ms = 0; ms < myselections.length; ms++) {				if (!myselections[ms].isValid ) { myselections.splice(ms,1); ms--; }	// remove this			}		},		check_myselections_valid_report = "",		check_myselections_valid = function(report, doalert, appendToStr) {			var invalid_count = 0, str = "";			for (var i = 0; i < myselections.length; i++) {				if (!report && !myselections[i].isValid ) return(false);				if (myselections[i].isValid) str += "[" + i + "] " + myselections[i].constructor.name + " id: " + myselections[i].id + " index: " + myselections[i].index + " isValid: " + myselections[i].isValid + "\n";				else {					str += "[" + i + "] isValid: " + myselections[i].isValid + "\n";					invalid_count++;				}			}			if (report) {				check_myselections_valid_report = "check_myselections_valid REPORT:\n\nnum myselections:" + myselections.length + "\ninvalid_count: " + invalid_count + "\n";				check_myselections_valid_report += "selected objects:\n" + list_objectConstructors(myselections) + "\n\n" + str;				if (doalert) alert(appendToStr + check_myselections_valid_report);			}			return(true);		},		list_objectConstructors = function(arr) {			var str = "", i;			for (i = 0; i < arr.length; i++) {				str += arr[i].constructor.name + (i < (arr.length-1) ? "," : "");			}			return(str);		},		check_textframes_valid_report = "",		check_textframes_valid = function(report, doalert, appendToStr) {			var invalid_count = 0, str = "";			for (var i = 0; i < textframes.length; i++) {				if (!report && !textframes[i].isValid ) return(false);				if (textframes[i].isValid) str += "[" + i + "] " + textframes[i].constructor.name + " id: " + textframes[i].id + " index: " + textframes[i].index + " isValid: " + textframes[i].isValid + (textframes[i].previousTextFrame ? (" ("+textframes[i].previousTextFrame.id+")") : "") +"\n";				else {					str += "[" + i + "] isValid: " + textframes[i].isValid + "\n";					invalid_count++;				}			}			check_textframes_valid_report = appendToStr + "check_textframes_valid REPORT:\nnum myselections:" + myselections.length + "\nnum textframes:" + textframes.length + "\ninvalid_count: " + invalid_count + "\n";			check_textframes_valid_report += "selected objects:\n" + list_objectConstructors(myselections) + "\n\n" + str;			if (report) {				if (doalert) alert(check_textframes_valid_report);			}			return(true);		},		splitFrame = function(theselection) {			var myselection,				i,				deleteframes = [],				nextframe, previousframe,				oldframe = null,		// the frame the insertion pointer is in				oldframePageItem = null,				oldFrameBottom = 0,				oldFrameTop = 0,				storyLabel = "",		// the label of the first story textbox (in a chain)				theParent = null,				newframe = [],				newFrameTop = 0,				newframeBaseLine = 0,				insertionPointAtParaIndex = null,				insertionPointFrameCharOffset = null,	// char index hwer the text flows from previous text frame into the one of the insertion Pointer				storyParagraphs = null,				numParasInStory = 0,				numparastokeep,				text_in_overflow = false,				inhibit_unoverflow = false,				wrapoffset,				hexcontents = [], hasXMLcharsOnly = true, c;										myselection = theselection;			if (!myselection) myselection = app.selection[0];			if (!(myselection instanceof InsertionPoint) && !(myselection instanceof Character)) {				//alert("myselection.constructor.name: " + myselection.constructor.name);				return(newframe);			}			if (typeof(myselection.parentTextFrames[0]) == 'undefined') {				// this is 'undefined for text in overflow (such text has no parentTextFrame)				//alert("myselection.parentTextFrames[0]: " + myselection.parentTextFrames[0]);				return(newframe);	// security return;			}			//if ((myselection.paragraphs.previousItem(myselection.paragraphs[0]) == null) ) return(newframe);	// must have a previous para			try {				setMeasurementUnitsPoints();				try {					oldframe = myselection.parentTextFrames[0];		// the frame the insertion pointer is in					// we will not adjust the new frame to 'unOverflowBox()' if the text already is in overflow					text_in_overflow = oldframe.overflows;					storyParagraphs = myselection.parent.paragraphs;					numParasInStory = storyParagraphs.length;					insertionPointAtParaIndex = myselection.parentStory.characters.itemByRange (myselection.parentStory.characters[0], myselection).paragraphs.length;					insertionPointFrameCharOffset = myselection.paragraphs[0].index;	// char index hwer the text flows from previous text frame into the one of the insertion Pointer					if (myselection instanceof Character) insertionPointAtParaIndex--;	// if it is a 'Character' selection, we have to subtract the current para					//alert("splitframe myselection story paragraphs: " + myselection.parent.paragraphs.length + "\ninsertionPointAtParaIndex: " + insertionPointAtParaIndex + "\nmyselection: " + myselection.constructor.name + "\nparent: " + myselection.parent);					//alert("splitframe paragraph chars: " + myselection.parent.paragraphs[insertionPointAtParaIndex].characters.length);					// check if the contents of this para is XML tags only: FEFF characters only					for (i = 0; i < myselection.parent.paragraphs[insertionPointAtParaIndex].characters.count(); i++) {						if (typeof(myselection.parent.paragraphs[insertionPointAtParaIndex].characters[i].contents.charCodeAt) != 'undefined') {							for (c = 0; c < myselection.parent.paragraphs[insertionPointAtParaIndex].characters[i].contents.length; c++) {								//alert("char code: " + myselection.parent.paragraphs[insertionPointAtParaIndex].characters[i].contents.charCodeAt(c));								if (myselection.parent.paragraphs[insertionPointAtParaIndex].characters[i].contents.charCodeAt(c) !== 0xfeff) {									hasXMLcharsOnly = false;									break;								}							}						}						else {								if (myselection.parent.paragraphs[insertionPointAtParaIndex].characters[i].contents !== 0xfeff) {									hasXMLcharsOnly = false;									break;								}						}						if (hasXMLcharsOnly === false) break;					}					//logmess("hasXMLcharsOnly: " + hasXMLcharsOnly + "\ncharacters: " + hex_array(myselection.parent.paragraphs[insertionPointAtParaIndex].characters) + "\n");					//logmess("splitFrame hasXMLcharsOnly: " + hasXMLcharsOnly + "\n\tinsertionPointAtParaIndex: " + insertionPointAtParaIndex + "\n");					if (hasXMLcharsOnly) return([]);					// if we are in overflowed text, some of above might break!					// so, we don't split in overflown text				} catch(ex) {					// set SS_settings.DEBUGexceptions accordingly to find the cause of this exception					debug_exception("Exception in function 'splitFrame' while getting oldframe params:\n", ex, oldframe);					return([]);				}				//alert("splitFrame insertionPointAtParaIndex: " + insertionPointAtParaIndex + "\ninsertionPointFrameCharOffset: " + insertionPointFrameCharOffset);				try { oldframe.locked = false; } catch(ex) {};	// unlock				try {					// we URGENTLY have to turn off text wrap or it will last LOOOOONG or will fail					//oldframe.textWrapPreferences.textWrapMode = TextWrapModes.NONE;					oldframePageItem = getPageItem(oldframe);					// calc how many paras we have to keep from start to insertion pointer					numparastokeep = numParasInStory - insertionPointAtParaIndex;					// BEFORE removing any lines from the original box: calculate everything!					try {	// this may fail, due to 							// a) text in overflow							// b) overlapping boxes, both set to text wrap runaround and therefore text will overflow suddenly						newFrameTop = calcFrameTop(myselection.paragraphs[0]);					// firstBaseline + firstLineAscent + anchored heights						} catch(ex) {																// MUST be claculated BEFORE oldFrameBottom						var halt_this = debug_exception("Exception in function 'splitFrame' at call 'calcFrameTop()':\n", ex, myselection.paragraphs[0]);						if (!halt_this) return([]);					}					//alert("newFrameTop: " + newFrameTop);					// adjust better by frame inset and border thickness					//already done by 'calcFrameTop':	newFrameTop -= (/*getFrameInsetSpacing(oldframe,0) +*/ getFrameStrokeWeight(oldframe));					oldFrameTop = oldframe.geometricBounds[0];	// is default					//alert("oldframe.paragraphs.length: " + oldframe.paragraphs.length + "\noldframe.parentStory.textContainers[1].paragraphs.length: " + oldframe.parentStory.textContainers[1].paragraphs.length);					if ((oldframe.paragraphs.length <= 1) && (SS_settings.frameAdjustMode > 0)) {						// CAUTION: if the topmost paragraph contains an anchored object, then we have troubles to get the very exact height needed!						// So, we ajust top of oldframe only if no further paragraphs can be splitted						oldFrameTop = calcFrameTop(oldframe.lines[0]);		// make frames as small as possible - also on 'empty' top space - runaround					}					oldFrameBottom = calcFrameBottom(storyParagraphs[insertionPointAtParaIndex - 1]);					//alert("oldFrameBottom: " + oldFrameBottom);					//alert("oldframe height: " + (oldFrameBottom - oldframe.geometricBounds[0]));					storyLabel = myselection.parentStory.textContainers[0].label;					// store label to copy to new frame					//alert("STORE storyLabel: " + storyLabel);					if (SS_settings.DEBUG > 0) alert("oldFrameBottom: " + oldFrameBottom + "\nnewFrameTop: " + newFrameTop);				} catch(ex) {					debug_exception("Exception in function 'splitFrame' while getting newframe params:\n", ex, oldframe);				}				if (SS_settings.DEBUG > 0) {					alert("OLDFRAME "							+ "\nparent type: " + myselection.parent							+ "\nstoryLabel: " + storyLabel							+ "\nframe has previous chained frame: " + (oldframe.previousTextFrame != null)							+ "\nframe has next chained frame: " + (oldframe.nextTextFrame != null)							+ "\n\nstory num text containers: " + myselection.parentStory.textContainers.length							+ "\nstory num frames: " + myselection.parentStory.textFrames.length + "           (incl. anchored)"							+ "\nstory total chars: " +myselection.parentStory.characters.length							+ "\nstory last char index: " +oldframe.characters.lastItem().index							+ "\nstory index of first para: " +myselection.parent.paragraphs[0].index							+ "\n\nstory total paras: " + numParasInStory							+ "\ninsertionPointAtParaIndex of total story: " + insertionPointAtParaIndex							+ "\ninsertionPointFrameCharOffset: " + insertionPointFrameCharOffset							+ "\n\ttype of this para: " + myselection.paragraphs[0]							+ "\nnumparastokeep at end of copy box: " + numparastokeep									+ "\n\t\tand to to delete at end of original story"							+ "\nbaseline of insertionPoint para: " + myselection.paragraphs[0].baseline							+ "\n\nselection parent frames: " + myselection.parentTextFrames.length							+ "\nselection index in total story characters: " + myselection.paragraphs[0].index							+ "\ncharacter offset from start of story"									+ "\n\t\tto the start of selection frame: " + oldframe.paragraphs[0].index							+ "\ntotal paras in the selection frame:  "+ oldframe.paragraphs.length							+ "\n\ndelete paras in total story index from:  "+insertionPointAtParaIndex + " to: " + (numParasInStory-1)							+ "\nfrom:  "+oldframe.paragraphs.item(insertionPointAtParaIndex) + " to: " + oldframe.paragraphs.item(numParasInStory-1)							);				}				// check if we have to split boxes or just have to unlink from previous frame				// if the insertion pointer is at the beginning of the frame containing the insertion pointer				if (insertionPointFrameCharOffset == oldframe.paragraphs[0].index) {					// unlink: make a copy and delete original					try {						var prevFrame = oldframe.previousTextFrame;						if (prevFrame) prevFrame.nextTextFrame = null; //NothingEnum.NOTHING;	// unlink from previous frame						newframe[0] = oldframe;	// say that we have done something						//alert("SETTING storyLabel to unlinked frame: " + storyLabel);						if (newframe[0].label == "") newframe[0].label = storyLabel;	// copy the storyLabel						// move ending paragraphs from original story						storyParagraphs.itemByRange(storyParagraphs[insertionPointAtParaIndex],storyParagraphs.lastItem()).move(LocationOptions.AT_BEGINNING, oldframe.parentStory);						if (SS_settings.DEBUG > 0) alert("'unklinking' text frame from previous: " + prevFrame);						//alert("lastItem: " + prevFrame.parentStory.characters.lastItem().contents);						if ( (prevFrame.parentStory.characters.lastItem().contents == SpecialCharacters.COLUMN_BREAK)							|| (prevFrame.parentStory.characters.lastItem().contents == SpecialCharacters.FRAME_BREAK)							) {							prevFrame.parentStory.characters.lastItem().contents = "";						}						else { // also, we have to remove the ending paragraph char from the unlinked previous frame							try {								if (typeof(prevFrame.parentStory.characters.lastItem().contents.charCodeAt) != 'undefined') {									if (prevFrame.parentStory.characters.lastItem().contents.charCodeAt(0) == 65279) {	// this is 'ZERO WIDTH NO-BREAK SPACE': U+FEFF - can not be removed!!!																														// XML-tagged stories can have para breaks like this: feff 0d feff, or: 0d feff feff										var x = prevFrame.parentStory.characters.count() - 1,											cnt = 1;										while (cnt < 4) {												//alert("remove: " + (x - cnt) + " : " + prevFrame.parentStory.characters[x - cnt].contents.charCodeAt(0));											if (prevFrame.parentStory.characters[x - cnt].contents.charCodeAt(0) == 13) {												prevFrame.parentStory.characters[x - cnt].remove();												break;											}											cnt++;										}																			}									else if (prevFrame.parentStory.characters.lastItem().contents.charCodeAt(0) == 13) prevFrame.parentStory.characters.lastItem().remove();								}							} catch(ex) {								// set SS_settings.DEBUGexceptions accordingly to find the cause of this exception								debug_exception("Exception in function 'splitFrame' during character delete:\n", ex, null);							}						}						// frame also must be minified						if (SS_settings.frameAdjustMode > 0) {							//alert("unlink oldframe");							minifyFrame(oldframe, false);						}					} catch(ex) {						debug_exception("Exception in function 'splitFrame' during unlink:\ntype: " + typeof(prevFrame.parentStory.characters.lastItem().contents.charCodeAt) + "\n", ex, null);					}				}				else {					try {						var newFrameBottom = 0;						nextframe = oldframe.nextTextFrame;						previousframe = oldframe.previousTextFrame;						// makes no speed difference, so we don't do unchain						oldframe.nextTextFrame = null;		// unchain now before duplicating because this frame will nor have a nextTextFrame any longer - the newframe[0] will take this chain						//				oldframe.previousTextFrame = null;						// duplicate the frame where the text cursor stands						theParent = getParentSpread(oldframe);						if (theParent) newframe[0] = oldframe.duplicate(theParent);						else newframe[0] = oldframe.duplicate();						try {							newframe[0].locked = false;						}						catch(ex) {							debug_exception("Exception in function 'splitFrame' during unlocking newframe[0]:\n", ex, newframe[0]);						};						// set textwrap top and bottom						wrapoffset = newframe[0].textWrapPreferences.textWrapOffset;	//  [top, left, bottom, right]						if ((wrapoffset != null) && (wrapoffset != NothingEnum.NOTHING)) {							//alert(wrapoffset + "\nis NothingEnum.NOTHING: " + (wrapoffset == NothingEnum.NOTHING ? 'yup' : 'no'));							try {								wrapoffset[0] = 0; wrapoffset[2] = 0;								newframe[0].textWrapPreferences.textWrapOffset = wrapoffset;							}							catch(ex) {								newframe[0].textWrapPreferences.textWrapOffset = 0;							}						}						try { newframe[0].parentStory.remove(); } catch(ex){}						newframe[0].previousTextFrame = null;						// not really needed	newframe[0].nextTextFrame = null;						try {							// set the new frame's coordinates							newframe[0].textFramePreferences.firstBaselineOffset = FirstBaseline.ASCENT_OFFSET;							// set new bottom according to contained text							newFrameBottom = newframe[0].geometricBounds[2] + getFrameStrokeWeight(newframe[0]);							newframe[0].geometricBounds = [newFrameTop, newframe[0].geometricBounds[1], newFrameBottom, newframe[0].geometricBounds[3]];	// [y1, x1, y2, x2]							// chain with old frame's chain							newframe[0].nextTextFrame = nextframe;						} catch(ex) {							debug_exception("Exception in function 'splitFrame' while setting newframe coordinates:\nnewframe[0].paragraphs.lastItem().isValid: " + newframe[0].paragraphs.lastItem().isValid + "\n", ex, oldframe);						}												// reset storyLabel						//alert("SETTING storyLabel to new frame: " + storyLabel);						if (newframe[0].label == "") newframe[0].label = storyLabel;	// copy the storyLabel						// move ending paragraphs from original story to newframe						// AFTER box newframe[0] is adjusted!						storyParagraphs.itemByRange(storyParagraphs[insertionPointAtParaIndex],storyParagraphs.lastItem()).move(LocationOptions.AT_BEGINNING, newframe[0].parentStory);						if (SS_settings.frameAdjustMode > 0) {							try {								unOverflowBox(newframe[0], "splitframe 1");								newFrameBottom = calcFrameBottom(newframe[0].parentStory.textContainers[0].lines.lastItem());								newFrameBottom += SS_settings.newframe_bottom_add_pix;								//alert("newFrameBottom: " + newFrameBottom + "\nnewFrameBottom orig: " + newframe[0].geometricBounds[2]);								newframe[0].geometricBounds = [newframe[0].geometricBounds[0], newframe[0].geometricBounds[1], newFrameBottom, newframe[0].geometricBounds[3]];	// set new y2							} catch(ex) {								debug_exception("Exception in function 'splitFrame' while setting newframe bottom:\n" + newframe[0].parentStory.textContainers[0].lines.lastItem().isValid + "\n", ex, oldframe);							}						}						// adjust newframe if necessary						// make sure newframe does not overflow but only, if it was not in overflow BEFORE						if (!text_in_overflow) {							unOverflowBox(newframe[0], "splitframe 2");							if (SS_settings.frameAdjustAuto > 0) {								newframe[0].fit(SS_settings.frameAdjustAuto);							}						}						// remove last paragraph character in oldframe						//alert("num chars in para: " + oldframe.parentStory.characters.count() + "\nlastItem contents: '" + oldframe.parentStory.characters.lastItem().contents + "'" + "\nlastItem-1 contents: '" + d2hs(oldframe.parentStory.characters[oldframe.parentStory.characters.count()-2].contents) + "'");						if ( (oldframe.parentStory.characters.lastItem().contents == SpecialCharacters.COLUMN_BREAK)							|| (oldframe.parentStory.characters.lastItem().contents == SpecialCharacters.FRAME_BREAK)							) {							oldframe.parentStory.characters.lastItem().contents = "";						}						else { // also, we have to remove the ending paragraph char from the unlinked previous frame							try {								//alert("lastItem contents.charCodeAt(0): '" + oldframe.parentStory.characters.lastItem().contents.charCodeAt(0) + "'" + "\ntext: " + text_string(oldframe.parentStory.characters, 10) + "\nhex: " + hex_string(oldframe.parentStory.characters, 10));								if (typeof(oldframe.parentStory.characters.lastItem().contents.charCodeAt) != 'undefined') {									if (oldframe.parentStory.characters.lastItem().contents.charCodeAt(0) == 65279) {	// this is 'ZERO WIDTH NO-BREAK SPACE': U+FEFF - can not be removed!!!																														// XML-tagged stories can have para breaks like this: feff 0d feff, or: 0d feff feff										var x = oldframe.parentStory.characters.count() - 1,											cnt = 1;										while (cnt < 4) {												//alert("remove: " + (x - cnt) + " : " + oldframe.parentStory.characters[x - cnt].contents.charCodeAt(0));											if (oldframe.parentStory.characters[x - cnt].contents.charCodeAt(0) == 13) {												oldframe.parentStory.characters[x - cnt].remove();												break;											}											cnt++;										}																			}									else if (oldframe.parentStory.characters.lastItem().contents.charCodeAt(0) == 13) oldframe.parentStory.characters.lastItem().remove();								}							} catch(ex) {								// set SS_settings.DEBUGexceptions accordingly to find the cause of this exception								debug_exception("Exception in function 'splitFrame' during character delete in oldframe\n", ex, null);							}						}						// chained frames also must be minified						if (SS_settings.frameAdjustMode > 0) {							minifyFrame(nextframe, true);						}												// adjust the oldframe bottom						//oldframe.geometricBounds = [oldframe.geometricBounds[0], oldframe.geometricBounds[1], oldFrameBottom + getFrameStrokeWeight(oldframe) , oldframe.geometricBounds[3]];						oldframe.geometricBounds = [oldFrameTop, oldframe.geometricBounds[1], oldFrameBottom + getFrameStrokeWeight(oldframe) , oldframe.geometricBounds[3]];						if (!inhibit_unoverflow && oldframe.overflows) {							if (SS_settings.textWrapMode >= 0) {								newframe[0].textWrapPreferences.textWrapMode = TextWrapModes.NONE;								//alert("overflow");							}							unOverflowBox(oldframe, "splitframe 3");						}						if (SS_settings.frameAdjustAuto > 0) {							oldframe.fit(SS_settings.frameAdjustAuto);						}						// set new frame in sequence of oldframe						/*						if (oldframePageItem != null) {							//oldframePageItem.select();							//newframe[0].bringToFront(oldframePageItem);						}						*/						// just for speed tests: ID will become very slow if more than 200-300 frames are on a page						//newframe[0].remove();					} catch(ex) {						debug_exception("Exception in function 'splitFrame' while adjusting newframe:\n", ex, null);					}				}				resetMeasurementUnits();				SS_settings.numParasSplitted++;				SS_settings.totalParasSplitted++;			} catch(ex) {				// enable this to find the cause of this exception				debug_exception("Exception in function 'splitFrame':\n", ex, null);			}			return(newframe);		},		do_splitFrame = function() {			var originalRedraw, originalPreflight, originalTool = app.toolBoxTools.currentTool, 				splitted = [],				p, paramatch,				groupMembers = null, groupParent = null,				startTextFrame, storyParas,				do_exit = false,				start_ticks = new Date().getTime(),				end_ticks = 0,				total_ticks = 0; 			originalPreflight = app.activeDocument.preflightOptions.preflightOff;			app.activeDocument.preflightOptions.preflightOff = true;						originalRedraw = app.scriptPreferences.enableRedraw;			app.scriptPreferences.enableRedraw = false;			SS_settings.totalParasSplitted = 0;			SS_settings.numParasSplitted = 0;			//alert("do_splitFrame: " + SS_settings.splitAtParaName + "\n\nlength: " + SS_settings.splitAtParaName.length + "\n\n[0]: '" + SS_settings.splitAtParaName[0] + "'\n\n[0] length: " + SS_settings.splitAtParaName[0].length);			//alert("SS_settings.splitAtParaName[0]: " + SS_settings.splitAtParaName[0]);			if (SS_settings.splitAtParaName[0] != "") {	// we split at all these paragraph style names				//check_textframes_valid(true, false, "");				//check_textframes_valid(true, true, "do_splitFrame START\n\n");				//logmess("do_splitFrame looping through " + textframes.length +" text frames\n");				for (selectionIdx = 0; selectionIdx < textframes.length; selectionIdx++) {					// check for STOP					if (do_exit || (ScriptUI.environment.keyboardState.ctrlKey && ScriptUI.environment.keyboardState.shiftKey)) {						alert("User abort");						break;					}					$.gc();					//alert("do_splitFrame START, frame: " + selectionIdx + " of " + textframes.length);					if (SS_settings.DEBUG > 0) alert("SPLIT at paragraph name: " + SS_settings.splitAtParaName);					// check if still is a valid textframe					if ( !textframes[selectionIdx].isValid ) {						//alert("textframes selectionIdx: " + selectionIdx + " of " + textframes.length + "\nisValid: " + textframes[selectionIdx].isValid);						continue;					}					// skip frames on MasterSpread					//alert(textframes[selectionIdx].parent.constructor.name);					if (textframes[selectionIdx].parent.constructor.name == "MasterSpread" ) {						//alert("textframes selectionIdx: " + selectionIdx + " of " + textframes.length + "\nisValid: " + textframes[selectionIdx].isValid);						continue;					}					// check layer (anchored objects are not on a layer)					try {						if (textframes[selectionIdx].itemLayer.visible == false) {	// is visible?							if (SS_settings.INCLUDE_HIDDEN_LAYERS <= 0) continue;						}						if (textframes[selectionIdx].itemLayer.locked == true) {	// is locked?							if (SS_settings.INCLUDE_LOCKED_LAYERS <= 0) continue;						}					} catch(ex) { continue; }					// check for *nosplit* label					if (noSplit(textframes[selectionIdx])) continue;					if (textframes[selectionIdx].parent instanceof Character) continue;	// this is an anchored textframe					if (textframes[selectionIdx].previousTextFrame) continue;	// we check the parent story frame only					//alert(typeof textframes[selectionIdx].startTextFrame);					if ( !textframes[selectionIdx].startTextFrame.isValid ) {						//alert("starttextframe: " + selectionIdx + " of " + textframes.length + "\nisValid: " + textframes[selectionIdx].startTextFrame.isValid);						continue;					}					if (typeof(textframes[selectionIdx].startTextFrame) == 'undefined') continue;					try {						startTextFrame = textframes[selectionIdx].startTextFrame;	// get first frame of story: is a 'TextFrame'					} catch(ex) { continue; }					if ((typeof(startTextFrame) == 'undefined') || (!startTextFrame)) continue;					// we need at least 2 paras to split a frame					if (startTextFrame.parentStory.paragraphs.length < 2) {						continue;					}					// preflight if this frame contains paragraphs to be splitted					//alert("do_splitFrame preflight");					paramatch = has_story_paraMatchName(startTextFrame);					//alert("paramatch: " + paramatch + "\n" + startTextFrame);					if (!paramatch) {						//alert("no match");						continue;					}					if ( (SS_settings.SILENT <= 0)						&& (textframes.length > 5)						&& (selectionIdx % 10 == 0)						) message(Product.applicationName + "\nSplitting paragraphs in frame " + (selectionIdx+1) + " of " + textframes.length + ". Please wait...");					try { textframes[selectionIdx].locked = false; } catch(ex) {};					// must ungroup or 'unOverflowBox' might loop loooong					if (textframes[selectionIdx].parent.constructor.name == 'Group') {						//curr not used; groupMembers = textframes[selectionIdx].parent.allPageItems;	// is array of PageItem						//curr not used; groupParent = textframes[selectionIdx].parent.parent;						textframes[selectionIdx].parent.ungroup();						//check_textframes_valid(true, true, "do_splitFrame after ungroup()\n\n");					}					// get the story paragraphs					storyParas = startTextFrame.parentStory.paragraphs;					if (SS_settings.DEBUG > 0) alert("firstStoryFrame: " + startTextFrame + "\n\t num storyParas: " + storyParas.length);					//logmess("do_splitFrame looping through " + storyParas.length +" paras\n");					var parastop = 0;					if (SS_settings.splitAtParaPos > 0) parastop = -1;					for (p = storyParas.length - 1; p > parastop; p--) {	// the first para can be ignored - is not split						//logmess("para index index p: " + p + " of " + storyParas.length + " paras");						if (ScriptUI.environment.keyboardState.ctrlKey && ScriptUI.environment.keyboardState.shiftKey) {							do_exit = true;							break;						}						paramatch = paraMatchName(storyParas[p].appliedParagraphStyle.name);						if (!paramatch) {							//alert("no match at para name:\n'" + storyParas[p].appliedParagraphStyle.name + "'");							continue;						}						//logmess("do_splitFrame matching para style: " + storyParas[p].appliedParagraphStyle.name +"\n");						//alert("do_splitFrame storyParas index #" + p + " of " + (storyParas.length-1) + "\nat para name: " + storyParas[p].appliedParagraphStyle.name);						if (SS_settings.DEBUG > 0) {							var cindex = storyParas[p].index;							alert("Found para '" + SS_settings.splitAtParaName + "\nat para index " + p + "\nat character index: " + startTextFrame.characters[cindex].index);						}						//logmess("do_splitFrame Found para '" + SS_settings.splitAtParaName + "\n\tat para index " + p + "\n\tat character index: " + startTextFrame.characters[storyParas[p].index] +"\n");						//alert("SS_settings.splitAtParaPos: " + SS_settings.splitAtParaPos);						if (SS_settings.splitAtParaPos == 0) {							// set the insertion pointer to the start of this paragraph							app.select(storyParas[p].characters[0]);							splitted = splitFrame(storyParas[p].characters[0]);						}						else if (SS_settings.splitAtParaPos == 1) {							// set the insertion pointer to the start of next paragraph							//alert("p: " + p + "\nstoryParas.length: " + storyParas.length);							if (p < (storyParas.length - 1)) {								app.select(storyParas[p+1].characters[0]);								splitted = splitFrame(storyParas[p+1].characters[0]);							}						}						if (SS_settings.DEBUG > 0) alert(textframes.length + "\n" + textframes[selectionIdx].constructor.name);						/*						  //DEBUG only							var cont = "";							for (var x=0; (x < storyParas[p].characters.count()) && (x < 30); x++) cont += storyParas[p].characters[x].contents;							alert("do_splitFrame at text: '" + cont + "'");							//message("Splitting frame " + selectionIdx + ": "  + "\n#paragraphs: " + startTextFrame.parentStory.paragraphs.length + " at paragraph: " + p + "\n#chars: " + storyParas[p].characters.count() + " '" + cont + "'");						*/						//logmess("do_splitFrame splitFrame splitted " + splitted.length + "\n");						if (splitted.length > 0) {							/* crashes in certain cases							if (groupMembers != null) {								for (var j = 0; j < splitted.length; j++) {									groupMembers.push(splitted[j]);								}							}							*/							// we have to re-get the original story paragraphs because we have splitted							storyParas = startTextFrame.parentStory.paragraphs;							if ( (SS_settings.SILENT <= 0)								&& (SS_settings.totalParasSplitted % 10 == 0)									) message(Product.applicationName + " working...\nParagraphs splitted: " + SS_settings.totalParasSplitted);							if (SS_settings.splitAtParaPos == 0) p = storyParas.length;	// and reset the counter (p-- will be done by for loop)							else if (SS_settings.splitAtParaPos == 1) p = storyParas.length - 1;							if (p < 2) {								if (SS_settings.frameAdjustMode > 0) {									minifyFrame(startTextFrame, false);								}								break;		// not enough paras to split							}						}						// for DEBUG: uncomment this to break after a certain number of splits												//if (SS_settings.totalParasSplitted % 10 == 0) recompose_document();	// recompose from time to time												// just a DEBUG break						//if (SS_settings.totalParasSplitted >= 200) { do_exit = true; break; }					}					// re-group					/* currently crashes!					if (groupMembers != null) {						//alert("groupParent: " + groupParent + "\ngroupMembers.length: " + groupMembers.length);						for (var j = 0; j < groupMembers.length; j++) {							if (!groupMembers[j].isValid) groupMembers.splice(j,1);						}						//alert("new groupParent: " + groupParent + "\ngroupMembers.length: " + groupMembers.length);						var newgroup = groupParent.groups.add(groupMembers);						newgroup.select(SelectionOptions.ADD_TO);					}					*/				}				//check_textframes_valid(true, true, "do_splitFrame DONE\n\n");				//check_textframes_valid(true, true, check_textframes_valid_report + "\n\n");				//check_myselections_valid(true, true, check_myselections_valid_report + "\n\n");				messageClose();				// when the script ends, the message window is closed immediately: we have to call an idle task to show the message				end_ticks = new Date().getTime();				total_ticks = end_ticks - start_ticks;				if (SS_external_call) {					if ((SS_settings.SILENT <= 0) && (SS_settings.NO_COMLETION_MESSAGE <= 0)) idle_message({mess:Product.applicationName + " complete:\nSplitted at " + SS_settings.totalParasSplitted + " pragraph" + (SS_settings.totalParasSplitted > 1 ? "s" : "") + " in " + (total_ticks/1000) + " seconds.", close:3000, force:true});				}				else message(Product.applicationName + " complete:\nSplitted at " + SS_settings.totalParasSplitted + " pragraph" + (SS_settings.totalParasSplitted > 1 ? "s" : "") + " in " + (total_ticks/1000) + " seconds.", undefined,true,true);			}			else {	// split at insertion pointer set by user				//	alert("app.selection.length: " + app.selection.length);				//logmess("do_splitFrame splitting at Insertion pointer\n");				if ( (app.selection.length == 1) && ((app.selection[0] instanceof InsertionPoint) || (app.selection[0] instanceof Character) || (app.selection[0] instanceof Text) || (app.selection[0] instanceof TextStyleRange)) )	{			// the cursor must be at the start of a paragraph					// make sure the insertion pointer is at start of paragraph					app.select(app.selection[0].paragraphs[0].characters[0]);					if (app.selection[0].paragraphs.previousItem(app.selection[0].paragraphs[0]) != null) {	// and must have a previous paragraph						// must ungroup or 'unOverflowBox' will loop long						ungroup(app.selection[0]);						splitted = splitFrame(app.selection[0]);						// we don't show a message here?					}					else {						// minify at least: chained frames also must be minified						//alert(getParentTextFrame(app.selection[0]));						if (SS_settings.frameAdjustMode > 0) {							minifyFrame(getParentTextFrame(app.selection[0]), false);						}						if (!(SS_settings.SILENT & 1)) alert(Product.applicationName + "\nNOTHING to split at insertion pointer\nNo previous paragraph available.\nInsertion pointer is at start of story.");					}				}				else {					if (!(SS_settings.SILENT & 1)) alert(Product.applicationName + "\nUnexpected Error\n\nCAN NOT SPLIT here!");				}			}			recompose_document();	// recompose if multi columns frames were splitted			app.scriptPreferences.enableRedraw = originalRedraw;			app.toolBoxTools.currentTool = originalTool;			app.activeDocument.preflightOptions.preflightOff = originalPreflight;			//	alert("Complete split: " + SS_settings.numParasSplitted);			return(SS_settings.numParasSplitted);		},		call_splitters = function(silent) {			var go = false;			SS_isBusy = true;			// test for multi columns text frames which must be converted to single columns frames first			try {				//logmess("check_singleColumnsSplitter START\n");				go = check_singleColumnsSplitter(silent);				//logmess("check_singleColumnsSplitter DONE, go: " + go + "\n");			} catch(ex) {				debug_exception("Exception in function 'check_singleColumnsSplitter':\n", ex);			}			if (go) {				//try {					//logmess("do_splitFrame START\n");					app.doScript(do_splitFrame, ScriptLanguage.javascript, undefined, UndoModes.ENTIRE_SCRIPT);					//logmess("do_splitFrame DONE\n");				/*				} catch(ex) {					debug_exception("Exception in function 'do_splitFrame':\n", ex);				}				*/			}			SS_isBusy = false;		},		numdocs_available = function() {			try {	// must try/catch: a document could be about to closing but window is still showing				var doc = app.activeDocument;	// this breaks when a document is closing				if (app.documents.length <= 0) return(0);			} catch(ex) {				return(0);			}			return(app.documents.length);		},		changed_activeDocument = function() {			var doc, doc_id = null, doc_name = "", doc_changed = false;			try {	// must try/catch: a document could be about to closing but window is still showing				doc = app.activeDocument;	// this breaks when a document is closing				if (app.documents.length > 0) {					doc_id = doc.id;					doc_name = doc.name;				}				else {					doc_id = null;					doc_name = "";				}			} catch(ex) {					doc_id = null;					doc_name = "";			}			if ((doc_id !== SS_wrk.activeDocumentID) || (doc_name != SS_wrk.activeDocumentName)) doc_changed = true;			else doc_changed = false;			//if (doc_changed) alert("doc changed:\n" + list_object(SS_wrk) + "\n\ndoc_id: " + doc_id + "\ndoc_name: " + doc_name);			//else alert("doc NOT changed:\n" + list_object(SS_wrk) + "\n\ndoc_id: " + doc_id + "\ndoc_name: " + doc_name);			SS_wrk.activeDocumentID = doc_id;			SS_wrk.activeDocumentName = doc_name;			return(doc_changed);		},		checkMySelection = function(silent, get_short, caller) {			// check if a document is open			var mysilent = false;			if ((typeof(silent) == 'undefined') || (silent == null)) {				if (!(SS_settings.SILENT & 1)) mysilent = false;				else mysilent = true;			}			else if (silent === true) mysilent = true;				 else if (silent === false) mysilent = false;			//alert("checkMySelection mysilent: " + mysilent + "\nsilent: " + silent + "\nget_short: " + get_short + "\ncaller: " + caller);						myselections = null;			num_textframes = 0;			allPageItems_in_textframes = false;			numDocsOpen = numdocs_available();			if (numDocsOpen <= 0) {				if (!silent) alert("Story Scissors\nA document must be open.\n\ntry again...");				return(1);			}			//alert(app.selection[0]);			// store current selection(s)			if (SS_settings.ENTIRE_DOCUMENT > 0) {				myselections = app.activeDocument.allPageItems;				allPageItems_in_textframes = true;				//DEBUG only				/*	var str = "myselections.length: " + myselections.length + "\n";					for (var s = 0; s < myselections.length; s++) {						str += s + ": " + myselections[s].constructor.name + "\n";					}					alert(str);				*/				//alert("checkMySelection - myselections contains " + myselections.length + " frames");			}			else {				// check if something is selected				if ( typeof app.selection[0] == 'undefined') {	// nothing selected					if (!mysilent) {						alert("Story Scissors\nA text frame must be selected to split multiple paragraphs\nor the insertion pointer must be set at the start of a paragraph to split at this point.\n\ntry again...");					}					return(2);				}				myselections = app.selection;			}			//alert("checkMySelection - myselections contains " + myselections.length + " items");			// count and store all text frames in the selection			countAllTextFrames(get_short);	// this directly sets num_textframes			//alert("num_textframes: " + num_textframes);			// abort if nothing selected			if (num_textframes <= 0) {				if (!mysilent) {					alert("Story Scissors\nA text frame must be selected to split multiple paragraphs\nor the insertion pointer must be set at the start of a paragraph to split at this point.\n\ntry again...");				}				if (SS_settings.ENTIRE_DOCUMENT <= 0) return(5);			}			return(0);		},		getParaStylesPop = function() {			//alert("getParaStylesPop: " + app.documents.length);			var PS_array = [], i, doc;			numDocsOpen = numdocs_available();			if (numDocsOpen <= 0) return([]);			try {	// must try/catch: a document could be about to closing but window is still showing				doc = app.activeDocument;			} catch(ex) { return([]); };			//alert("doc: " + doc);			for (i = 1; i < doc.allParagraphStyles.length; i++) {	// dont show [ No Paragraph Style ]				PS_array[PS_array.length] = doc.allParagraphStyles[i].name;			}			return(PS_array);		},		updateParaStylesPop = function() {			//alert("updateParaStylesPop");			SS_wrk.dlgw.leftGroup.listBox.removeAll();			numDocsOpen = app.documents.length;			if (numDocsOpen <= 0) return;			var items = getParaStylesPop();			//alert("num para styles: " + items.length);			for (var i = 0; i < items.length; i++) SS_wrk.dlgw.leftGroup.listBox.add("item", items[i]);		},		in_checkSelection = false,		checkSelection = function (e, get_short, caller) {			var do_updateParaStylesPop = true,				myEvent,				myshort;			if (in_checkSelection == true) return;			in_checkSelection = true;	// prevent reentrance from multiple events			myEvent = e || {eventType:'undefined'};			if ((typeof(get_short) == 'undefined') || (get_short == null)) myshort = false;			else myshort = get_short;			//alert("checkSelection Event:\n\n" + list_object(myEvent));			switch (myEvent.eventType) {				case 'ParagraphStyleslistBox.onChange':					do_updateParaStylesPop = false;					break;				case 'entireDocumentCheck.onClick':					do_updateParaStylesPop = false;					// fall through				default:					myselections_arefine = checkMySelection(true, myshort, caller);				break;			}			numDocsOpen = numdocs_available();			if (do_updateParaStylesPop) {				if (changed_activeDocument()) updateParaStylesPop();			}			// set dialog texts			if (numDocsOpen <= 0) {				SS_wrk.dlgw.leftGroup.title.text = "No document is open";				SS_wrk.dlgw.leftGroup.message.text = "Please open a document.";			}			else {				//alert("myselections_arefine: " + myselections_arefine);				switch (myselections_arefine) {					case 2:	// no frame selected						SS_wrk.dlgw.leftGroup.title.text = "First select one or more frames to split and then\nselect one or more paragraph styles";						SS_wrk.dlgw.leftGroup.message.text = "Select one or more frames to split!";						break;					default:						SS_wrk.dlgw.leftGroup.title.text = "Select one or more paragraph styles:";						SS_wrk.dlgw.leftGroup.message.text = "cmd+Click to select multiple styles.\nThen click the [ Split ] button.";						break;				}			}			if (DEBUGselects > 0) SS_wrk.dlgw.rightGroup.numSelectsText.text = (num_textframes == enough_textframes ? "Have" : num_textframes) + " text frame" + (num_textframes > 1 ? "s" : "") + " selected " + myselections_arefine;			// set dialog buttons			//alert("myselections_arefine: " + myselections_arefine + "\nselection[0] name: " + myselections[0].constructor.name + "\napp.selection[0] name: " + app.selection[0].constructor.name);			// enable/disable 'split' button			if ((myselections_arefine != 0) 				|| (	(SS_wrk.dlgw.leftGroup.listBox.selection == null)					&& 	!((myselections[0].constructor.name == 'InsertionPoint') || (myselections[0].constructor.name == 'Character') || (app.selection[0] instanceof Text) || (app.selection[0] instanceof TextStyleRange))					)				) {	// disable 'split' button				//alert("disable 'split' button");				SS_wrk.dlgw.rightGroup.btnPanel.splitBtn.enabled = false;			}			else {	// enable 'split' button				//alert("enable 'split' button");				SS_wrk.dlgw.rightGroup.btnPanel.splitBtn.enabled = true;			}			// enable/disable 'split multi frames' button			if (myselections_arefine != 0) SS_wrk.dlgw.rightGroup.multicolPanel.multiframesSplitBtn.enabled = false;			else SS_wrk.dlgw.rightGroup.multicolPanel.multiframesSplitBtn.enabled = true;			in_checkSelection = false;		},		// keep track of selection changes		dialogEventListeners_disabled = false,		app_AFTER_SELECTION_CHANGED_hdl = null,		app_AFTER_SELECTION_CHANGED = function () {			if (dialogEventListeners_disabled) return;			if (SS_wrk.dlgw == null) return;			if (SS_isBusy) return;			// sorry, we are working (splitting columns or paras)			//alert("app_AFTER_SELECTION_CHANGED");			checkSelection({eventType:"app.AFTER_SELECTION_CHANGED"}, true, "app_AFTER_SELECTION_CHANGED");		},		// keep track of selection changes		dlgw_AFTER_SELECTION_CHANGED = function () {			if (dialogEventListeners_disabled) return;			if (SS_wrk.dlgw == null) return;			if (SS_isBusy) return;			// sorry, we are working (splitting columns or paras)			checkSelection({eventType:"dlgw.AFTER_SELECTION_CHANGED"}, true, "dlgw_AFTER_SELECTION_CHANGED");		},		// event listeners used only by the dialog window		addDialogEventListeners = function() {			dialogEventListeners_disabled = false;			var isactive = false, hdl = 'undefined', l;			if (SS_wrk.dlgw == null) return(false);						//SS_wrk.dlgw.addEventListener(Event.AFTER_SELECTION_CHANGED, dlgw_AFTER_SELECTION_CHANGED,false);			// check if this listener already is set (as we can not remove it)			for (l = 0; l < app.eventListeners.length; l++) {				//alert(list_object(app.eventListeners[l]));				if (app.eventListeners[l].name == 'StoryScissors app_AFTER_SELECTION_CHANGED') {					//alert("app_AFTER_SELECTION_CHANGED is already active");					isactive = true;					break;				}			}			if (!isactive) {				app_AFTER_SELECTION_CHANGED_hdl = app.addEventListener('afterSelectionChanged', app_AFTER_SELECTION_CHANGED,false);				if (app_AFTER_SELECTION_CHANGED_hdl) app_AFTER_SELECTION_CHANGED_hdl.name = "StoryScissors app_AFTER_SELECTION_CHANGED";				//alert("app_AFTER_SELECTION_CHANGED_hdl: " + app_AFTER_SELECTION_CHANGED_hdl);				//alert(list_object(app_AFTER_SELECTION_CHANGED_hdl));			}			return(true);		},		removeDialogEventListeners = function(caller) {			dialogEventListeners_disabled = true;			if (SS_wrk.dlgw == null) return(false);			//SS_wrk.dlgw.removeEventListener(Event.AFTER_SELECTION_CHANGED, dlgw_AFTER_SELECTION_CHANGED,false);						try {				var removed = app.removeEventListener(Event.AFTER_SELECTION_CHANGED, app_AFTER_SELECTION_CHANGED,false);				//alert("removed: " + removed + "\n caller: " + caller);				if (removed) app_AFTER_SELECTION_CHANGED_hdl = null;			} catch(ex) {			}			// all listeners should now be removed!!			/*			if (app.eventListeners.length > 0) {				alert("2 app.eventListeners.length: " + app.eventListeners.length);				// check if this listener already is set (as we can not remove it)				for (var l = 0; l < app.eventListeners.length; l++) {					if (app.eventListeners[l].eventType == 'afterSelectionChanged') {						alert("app_AFTER_SELECTION_CHANGED is STILL active");					}				}			}			*/			return(true);		},		set_mainDialogTitle = function() {			if (SS_wrk.dlgw == null) return;			SS_wrk.dlgw.text = Product.applicationName + " v" + Product.versionStr + "." + Product.sub_version;		},		set_mainDialogHint = function(text) {			if (SS_wrk.dlgw == null) return;			SS_wrk.dlgw.rightGroup.hint.text = text;		},		/****************************		 * Show the main splitter dialog		 */		showMainDialog = function (doupdate, do_close) {			var go = 0,				windowTitle,				windowFont, fontTitle, font, fontHelp,				bluepen,				labelSize,				editSize,				fgColor, bgColor, bgColorDisabled,				cleanUpDialog = function() {					removeDialogEventListeners("cleanUpDialog");					app.cancelAllTasks();					//alert("cleanUpDialog DONE");				},				close_dlgw = function () {					SS_wrk.dlgw.onClose = null;	// make sure to remove us because we are called multiple times when dialog is closing					cleanUpDialog();					go = false;					SS_wrk.dlgw.close(0);					//SS_wrk.dlgw = null;					SS_wrk.isopen = false;					// and store current settings					store_settings();				};			if ( (typeof(do_close) != 'undefined') && (do_close == true) ) {				close_dlgw();				return;			}			if (SS_wrk.isopen == true) {				SS_wrk.dlgw.show();				return;			}			SS_wrk.dlgw = new Window('palette', "", undefined, {resizeable:false, closeButton: true, maximizeButton:false, minimizeButton:false});			set_mainDialogTitle();			// set up some window variables			windowFont = SS_wrk.dlgw.graphics.font;			fontTitle = ScriptUI.newFont ( windowFont.name, windowFont.name.style, 14 );			font = ScriptUI.newFont ( windowFont.name, windowFont.name.style, 11 );			fontHelp = ScriptUI.newFont ( windowFont.name, 'BOLD', 18 );			bluepen = SS_wrk.dlgw.graphics.newPen (SS_wrk.dlgw.graphics.PenType.SOLID_COLOR, [0,0,1,1], 1);			bgColor = SS_wrk.dlgw.graphics.newBrush (SS_wrk.dlgw.graphics.BrushType.SOLID_COLOR, [0.95, 0.95, 0.95, 1]);			bgColorDisabled = SS_wrk.dlgw.graphics.newBrush (SS_wrk.dlgw.graphics.BrushType.SOLID_COLOR, [0.95, 0.95, 0.95, 1]);			labelSize = [115,1.8*font.size];			editSize = [105,1.8*font.size];			// set up the window			SS_wrk.dlgw.graphics.font = font;			//SS_wrk.dlgw.graphics.backgroundColor = bgColor;			SS_wrk.dlgw.orientation = 'row';			if ((SS_settings.dlgw_location !== null) && (SS_settings.dlgw_location.length == 2)) SS_wrk.dlgw.location = SS_settings.dlgw_location;			SS_wrk.dlgw.margins = [7,7,7,7];			SS_wrk.dlgw.alignChildren = ['left','top'];			SS_wrk.dlgw.alignment = ['left','top'];			//------------------------------			// items on left side			SS_wrk.dlgw.leftGroup = SS_wrk.dlgw.add('group');			SS_wrk.dlgw.leftGroup.orientation = 'column';			SS_wrk.dlgw.leftGroup.alignChildren = ['left','top'];			SS_wrk.dlgw.leftGroup.alignment = ['left','top'];			SS_wrk.dlgw.leftGroup.spacing = 5;				SS_wrk.dlgw.leftGroup.title = SS_wrk.dlgw.leftGroup.add('statictext', undefined, "Select one or more paragraph styles:", {multiline:true});					SS_wrk.dlgw.leftGroup.title.graphics.font = font;					SS_wrk.dlgw.leftGroup.title.preferredSize = [300,30];				var paraStyles = getParaStylesPop();				SS_wrk.dlgw.leftGroup.listBox = SS_wrk.dlgw.leftGroup.add( "listbox", undefined, "", {multiselect:true, items:paraStyles}); 					SS_wrk.dlgw.leftGroup.listBox.preferredSize = [ 290, 290 ];				SS_wrk.dlgw.leftGroup.message = SS_wrk.dlgw.leftGroup.add('statictext', undefined, "", {multiline:true});					SS_wrk.dlgw.leftGroup.message.graphics.font = font;					//SS_wrk.dlgw.leftGroup.message.preferredSize = [300,30];					SS_wrk.dlgw.leftGroup.message.size = [300,30];					SS_wrk.dlgw.leftGroup.message.maximumSize = [300,160];				//SS_wrk.dlgw.leftGroup.helpButton = SS_wrk.dlgw.leftGroup.add('statictext', undefined, " ? ");				SS_wrk.dlgw.leftGroup.helpButton = SS_wrk.dlgw.leftGroup.add('button', undefined, "?", {name:'Help'});					SS_wrk.dlgw.leftGroup.helpButton.size = [30,30];	// help button					SS_wrk.dlgw.leftGroup.helpButton.alignment = ['right','top'];					SS_wrk.dlgw.leftGroup.helpButton.helpTip = "Show Manual";	// Show Manual			//------------------------------			// items on right side			SS_wrk.dlgw.rightGroup = SS_wrk.dlgw.add('group');			SS_wrk.dlgw.rightGroup.orientation = 'column';			SS_wrk.dlgw.rightGroup.alignChildren = ['fill','top'];			SS_wrk.dlgw.rightGroup.alignment = ['fill','top'];				/*******/				SS_wrk.dlgw.rightGroup.btnPanel = SS_wrk.dlgw.rightGroup.add('panel', undefined, '');					SS_wrk.dlgw.rightGroup.btnPanel.preferredSize = [150,80];					SS_wrk.dlgw.rightGroup.btnPanel.title = SS_wrk.dlgw.rightGroup.btnPanel.add('statictext', undefined, "Paragraph Splitter");						SS_wrk.dlgw.rightGroup.btnPanel.title.graphics.font = fontTitle;					SS_wrk.dlgw.rightGroup.btnPanel.splitBtn = SS_wrk.dlgw.rightGroup.btnPanel.add('button', undefined, "Split", {name:'Split'});					SS_wrk.dlgw.rightGroup.btnPanel.splitBtn.helpTip = "Start story splitting";	// Start story splitting					SS_wrk.dlgw.rightGroup.btnPanel.cancelBtn = SS_wrk.dlgw.rightGroup.btnPanel.add('button', undefined, "Close", {name:'Close'});					SS_wrk.dlgw.rightGroup.btnPanel.cancelBtn.helpTip = "Close StoryScissors window";	// Close StoryScissors window				SS_wrk.dlgw.rightGroup.entireDocumentCheck = SS_wrk.dlgw.rightGroup.add("checkbox", undefined, "Entire Document");					SS_wrk.dlgw.rightGroup.entireDocumentCheck.value = (SS_settings.ENTIRE_DOCUMENT > 0 ? true : false);					SS_wrk.dlgw.rightGroup.entireDocumentCheck.graphics.font = font;					SS_wrk.dlgw.rightGroup.entireDocumentCheck.helpTip = "Process entire document";	// Process entire document				SS_wrk.dlgw.rightGroup.frameAdjustModeCheck = SS_wrk.dlgw.rightGroup.add("checkbox", undefined, "Frames as small as possible");					SS_wrk.dlgw.rightGroup.frameAdjustModeCheck.value = (SS_settings.frameAdjustMode > 0 ? true : false);					SS_wrk.dlgw.rightGroup.frameAdjustModeCheck.graphics.font = font;					SS_wrk.dlgw.rightGroup.frameAdjustModeCheck.helpTip = "If checked, split frames will be made as small as posiible";	// If checked, frames will be made as small as posiible				SS_wrk.dlgw.rightGroup.silentMultiColSplitCheck = SS_wrk.dlgw.rightGroup.add("checkbox", undefined, "Silently split \nmulti-column frames");					SS_wrk.dlgw.rightGroup.silentMultiColSplitCheck.value = (SS_settings.SILENT_COLSPLIT > 0 ? true : false);					SS_wrk.dlgw.rightGroup.silentMultiColSplitCheck.graphics.font = font;					SS_wrk.dlgw.rightGroup.silentMultiColSplitCheck.helpTip = "Silently split muti-column text frames into chained frames";	// Silently split muti-column text frames into chained frames				/*******/				SS_wrk.dlgw.rightGroup.multicolPanel = SS_wrk.dlgw.rightGroup.add('panel', undefined, '');					SS_wrk.dlgw.rightGroup.multicolPanel.title = SS_wrk.dlgw.rightGroup.multicolPanel.add('statictext', undefined, "Multi Columns Splitter");						SS_wrk.dlgw.rightGroup.multicolPanel.title.graphics.font = fontTitle;					SS_wrk.dlgw.rightGroup.multicolPanel.multiframesSplitBtn = SS_wrk.dlgw.rightGroup.multicolPanel.add('button', undefined, "Frame Split", {name:'FrameSplit'});					SS_wrk.dlgw.rightGroup.multicolPanel.multiframesSplitBtn.helpTip = "Split multicolumn text frames into threaded single column frames";	// Split multicolumn text frames into threaded single column frames				//var spacer20 = SS_wrk.dlgw.rightGroup.add('statictext', undefined, ""); spacer20.size = [10,5];	// spacer				/*******/				SS_wrk.dlgw.rightGroup.hint = SS_wrk.dlgw.rightGroup.add('edittext', undefined, "", {multiline:true /*, borderless:true*/});					SS_wrk.dlgw.rightGroup.hint.enabled = true;					SS_wrk.dlgw.rightGroup.hint.readonly = true;					SS_wrk.dlgw.rightGroup.hint.graphics.font = font;					//SS_wrk.dlgw.rightGroup.hint.graphics.backgroundColor = bgColor;					//SS_wrk.dlgw.rightGroup.hint.graphics.disabledBackgroundColor = bgColorDisabled;					SS_wrk.dlgw.rightGroup.hint.size = [120,70];					SS_wrk.dlgw.rightGroup.hint.text = "Processing message shown here.";				SS_wrk.dlgw.rightGroup.silentCheck = SS_wrk.dlgw.rightGroup.add("checkbox", undefined, "no messaages");					SS_wrk.dlgw.rightGroup.silentCheck.value = (SS_settings.SILENT > 0 ? true : false);					SS_wrk.dlgw.rightGroup.silentCheck.graphics.font = font;					SS_wrk.dlgw.rightGroup.silentCheck.helpTip = "Don't show processing messages";	// Don't show messages				if (DEBUGselects > 0) {					SS_wrk.dlgw.rightGroup.numSelectsText = SS_wrk.dlgw.rightGroup.add('statictext', undefined, (num_textframes == enough_textframes ? "Have" : num_textframes) + " text frame" + (num_textframes > 1 ? "s" : "") + " selected " + myselections_arefine);						SS_wrk.dlgw.rightGroup.numSelectsText.graphics.font = font;				}			/***********************				The dialog button and event handlers			*/			// Split button			SS_wrk.dlgw.rightGroup.btnPanel.splitBtn.onClick = function() {				//alert("selection: " + SS_wrk.dlgw.leftGroup.listBox.selection);				//alert("mmyselections[0].constructor.name: " + myselections[0].constructor.name);				if (SS_wrk.dlgw.leftGroup.listBox.selection == null) {					if ((myselections[0].constructor.name == 'InsertionPoint') || (myselections.constructor.name == 'Character') || (app.selection[0] instanceof Text) || (app.selection[0] instanceof TextStyleRange)) {						SS_settings.splitAtParaName = [""];						myselections_arefine = checkMySelection(false, false, "splitBtn.onClick 0");						if (myselections_arefine != 0) return;						// call the splitters						app.doScript(call_splitters, ScriptLanguage.javascript, [false], UndoModes.ENTIRE_SCRIPT);					}					else {	// nothing selected: cancel						SS_settings.splitAtParaName = [""];					}				}				else {					SS_settings.splitAtParaName = SS_wrk.dlgw.leftGroup.listBox.selection;					SS_settings.splitAtParaName = setSplitAtParaName(SS_settings.splitAtParaName);					// test if something is selected					myselections_arefine = checkMySelection(false, false, "splitBtn.onClick 1");					if (myselections_arefine != 0) return;					// call the splitters					app.doScript(call_splitters, ScriptLanguage.javascript, [false], UndoModes.ENTIRE_SCRIPT);				}			};			// multi columns frames Split button			SS_wrk.dlgw.rightGroup.multicolPanel.multiframesSplitBtn.onClick = function() {				myselections_arefine = checkMySelection(false, false, "multiframesSplitBtn.onClick");				if (myselections_arefine != 0) return;				SS_isBusy = true;					//go = check_singleColumnsSplitter(true, true);				// like this, we have the 'undo' feature:				app.doScript(check_singleColumnsSplitter, ScriptLanguage.javascript, [true, true], UndoModes.ENTIRE_SCRIPT);				SS_isBusy = false;			};						// Cancel button			SS_wrk.dlgw.rightGroup.btnPanel.cancelBtn.onClick = close_dlgw;			SS_wrk.dlgw.onClose = close_dlgw;	// onClose is called multiple times!!!!!			// entire document check			SS_wrk.dlgw.rightGroup.entireDocumentCheck.onClick = function() {				SS_settings.ENTIRE_DOCUMENT = SS_wrk.dlgw.rightGroup.entireDocumentCheck.value == true ? 1 : 0;				checkSelection({eventType:"entireDocumentCheck.onClick"}, true, "entireDocumentCheck.onClick");			};			// frameAdjustModeCheck			SS_wrk.dlgw.rightGroup.frameAdjustModeCheck.onClick = function() {				SS_settings.frameAdjustMode = SS_wrk.dlgw.rightGroup.frameAdjustModeCheck.value == true ? 1 : 0;			};			// silent multi column split check			SS_wrk.dlgw.rightGroup.silentMultiColSplitCheck.onClick = function() {				SS_settings.SILENT_COLSPLIT = SS_wrk.dlgw.rightGroup.silentMultiColSplitCheck.value == true ? 1 : 0;			};			// silent check			SS_wrk.dlgw.rightGroup.silentCheck.onClick = function() {				SS_settings.SILENT = SS_wrk.dlgw.rightGroup.silentCheck.value == true ? 1 : 0;			};			// selection change			SS_wrk.dlgw.leftGroup.listBox.onChange = function(e) {				//alert("listBox.onChange:\n\n" +  this.selection);				if ( this.selection != null ) { // is a string value for single selection or an array strings					SS_settings.splitAtParaName = SS_wrk.dlgw.leftGroup.listBox.selection;					SS_settings.splitAtParaName = setSplitAtParaName(SS_settings.splitAtParaName);				}				else SS_settings.splitAtParaName = [""];				checkSelection({eventType:"ParagraphStyleslistBox.onChange"}, true, "listBox.onChange");			};			// keep track of window position changes			SS_wrk.dlgw.onMove = function(e) {				SS_settings.dlgw_location = SS_wrk.dlgw.location;				//alert(SS_wrk.dlgw_location);			};			// add dialog event listeners			addDialogEventListeners();			// Help button			SS_wrk.dlgw.leftGroup.helpButton.onClick = function (e) {															var helpfilename = scriptPath + "/Manual.jsx",																helpfile = new File(helpfilename);															try { app.doScript(helpfile,ScriptLanguage.javascript); }															catch(ex) {}														};			if ((typeof(doupdate) != 'undefined') && (doupdate != false)) checkSelection(null, true, "dialog main");			// Display the dialog box.			go = SS_wrk.dlgw.show();			SS_wrk.isopen = true;			//alert(go);			return(go);		},		/****************************		 * check if exists or create folder structure		 */		create_folderstructure = function (thepath) {			if (thepath == "") return(0);	// nothing to check = noerror			var f = new Folder(thepath);			if (f.exists == true) return(0);			f.create();			//alert("create_folderstructure()\nthepath: " + thepath + "\nf.exists: " + f.exists);			if (f.exists == false) {				var folder_names = thepath.split("/");				var fldr = null;				var fldr_path = "";				for (var i = 0; i < folder_names.length; i++) {					if (folder_names[i] == "") continue;					fldr_path += folder_names[i] + "/";					fldr = new Folder(fldr_path);					fldr.create();				}				f = new File(thepath);	// recheck for existance				if (f.exists == false) {					return(1);				}			}			return(0);		},		settings_path = Folder.userData + "/StoryScissors/",		settings_name = "SS_settings.set",		store_settings = function() {			var	ret = create_folderstructure(settings_path),				f = new File(settings_path + settings_name);			f.encoding = "UTF-8";			ret = f.open("w");			//alert("save settings:\n\n" + list_object(SS_settings, undefined, "SS_set", true));			ret = f.write(list_object(SS_settings, undefined, "SS_set", true));			ret = f.close();			return(ret ? 0 : 1);		},		load_settings = function() {			var ret = 0,				settings = "",				f = new File(settings_path + settings_name);			if (f.exists == false) {	// create folder and stor current settings				ret = store_settings();				return(ret);			}			ret = f.open("r");			if (!ret) return(1);			settings = f.read();			ret = f.close();			if (settings == "") return(1);						//alert("load settings:\n\n" + settings);			try {				settings = eval(settings);			}			catch(ex) {				return(1);			}			for (var key in settings) SS_settings[key] = settings[key];	// update current structure			//alert("after load settings:\n\n" + list_object(SS_settings));			return(ret ? 0 : 1);		},		/**		 * Log/show messages		 * The _logger package must be installed in inDesigns Scripts Panel path.		 */		logmess = function(mess) {			var cmd = "";			if (SS_settings.DEBUGlog > 0) {				cmd = "#targetengine \"logger\"\rlog();\r";				app.scriptArgs.setValue("logmess", mess);				app.doScript(cmd, ScriptLanguage.javascript, [mess], UndoModes.ENTIRE_SCRIPT);			}		};	//-------------------------------	// Let's go	var main = function(theSplitAtParaName, options) {		SS_external_call = false;		DO_NOTHING = 0;		// load previous stored settings		load_settings();		SS_settings.numParasSplitted = 0;		SS_settings.totalParasSplitted = 0;		SS_returncode = 0;	// reset return code		if (typeof(theSplitAtParaName) != 'undefined') {			SS_settings.splitAtParaName = setSplitAtParaName(theSplitAtParaName);			SS_external_call = true;		}		if (typeof(options) != 'undefined') {			//alert("options:\n" + list_object(options));			save_settings(SS_settings);	// save settings			for (var key in options) {				switch (key) {					case 'splitAtParaName':						SS_settings.splitAtParaName = options[key];						break;					case 'splitAtParaPos':						SS_settings.splitAtParaPos = options[key];						break;					case 'DEBUG':						SS_settings.DEBUG = options[key];						break;					case 'DOCUMENT_recompose':						SS_settings.DOCUMENT_recompose = options[key];						break;					case 'NO_MENU':						SS_settings.NO_MENU = options[key];						break;					case 'SILENT':						SS_settings.SILENT = options[key];						break;					case 'SILENT_COLSPLIT':						SS_settings.SILENT_COLSPLIT = options[key];						break;					case 'NO_COMLETION_MESSAGE':						SS_settings.NO_COMLETION_MESSAGE = options[key];						break;					case 'ENTIRE_DOCUMENT':						SS_settings.ENTIRE_DOCUMENT = options[key];						break;					case 'frameAdjustMode':						SS_settings.frameAdjustMode = options[key];						break;					case 'frameAdjustAuto':						SS_settings.frameAdjustAuto = options[key];						break;					case 'DO_NOTHING':						DO_NOTHING = options[key];						break;				}			}			SS_external_call = true;		}		// get call override parameters from a caller script		try {			if ( app.scriptArgs.isDefined("splitAtParaName") ) {				SS_settings.splitAtParaName = setSplitAtParaName(app.scriptArgs.getValue("splitAtParaName"));				haveCallerScript = true;			}		} catch(e) {}		try {			if ( app.scriptArgs.isDefined("splitAtParaPos") ) {				SS_settings.splitAtParaPos = parseInt(app.scriptArgs.getValue("splitAtParaPos"), 10);				haveCallerScript = true;			}		} catch(e) {}		try {			if ( app.scriptArgs.isDefined("DEBUG") ) {				SS_settings.DEBUG = parseInt(app.scriptArgs.getValue("DEBUG"), 10);				haveCallerScript = true;			}		} catch(e) {}		try {			if ( app.scriptArgs.isDefined("DOCUMENT_recompose") ) {				SS_settings.DOCUMENT_recompose = parseInt(app.scriptArgs.getValue("DOCUMENT_recompose"), 10);				haveCallerScript = true;			}		} catch(e) {}		try {			if ( app.scriptArgs.isDefined("NO_MENU") ) {				SS_settings.NO_MENU = parseInt(app.scriptArgs.getValue("NO_MENU"), 10);				haveCallerScript = true;			}		} catch(e) {}		try {			if ( app.scriptArgs.isDefined("SILENT") ) {				SS_settings.SILENT = parseInt(app.scriptArgs.getValue("SILENT"), 10);				haveCallerScript = true;			}		} catch(e) {}		try {			if ( app.scriptArgs.isDefined("SILENT_COLSPLIT") ) {				SS_settings.SILENT_COLSPLIT = parseInt(app.scriptArgs.getValue("SILENT_COLSPLIT"), 10);				haveCallerScript = true;			}		} catch(e) {}		try {			if ( app.scriptArgs.isDefined("NO_COMLETION_MESSAGE") ) {				SS_settings.NO_COMLETION_MESSAGE = parseInt(app.scriptArgs.getValue("NO_COMLETION_MESSAGE"), 10);				haveCallerScript = true;			}		} catch(e) {}		try {			if ( app.scriptArgs.isDefined("ENTIRE_DOCUMENT") ) {				SS_settings.ENTIRE_DOCUMENT = parseInt(app.scriptArgs.getValue("ENTIRE_DOCUMENT"), 10);				haveCallerScript = true;			}		} catch(e) {}		try {			if ( app.scriptArgs.isDefined("frameAdjustMode") ) {				SS_settings.frameAdjustMode = parseInt(app.scriptArgs.getValue("frameAdjustMode"), 10);				haveCallerScript = true;			}		} catch(e) {}		try {			if ( app.scriptArgs.isDefined("frameAdjustAuto") ) {				SS_settings.frameAdjustAuto = app.scriptArgs.getValue("frameAdjustAuto");				haveCallerScript = true;			}		} catch(e) {}		try {			if ( app.scriptArgs.isDefined("DO_NOTHING") ) {				DO_NOTHING = app.scriptArgs.getValue("DO_NOTHING");				haveCallerScript = true;			}		} catch(e) {}		// start logger if DEBUG enabled		if (SS_settings.DEBUGlog > 0) {			try {				logmess("");			} catch(ex) { // not reachable: start logger				try {					var scriptFile = new File(getScriptsPath() + "/../../_logger/logger.jsx");					app.doScript(scriptFile, ScriptLanguage.javascript, undefined, UndoModes.ENTIRE_SCRIPT);				} catch(ex) { // not reachable: complain					alert("Could not start logger from path: " + getScriptsPath() + "/../../_logger/logger.jsx");					exit(1);				}			}		}		//alert("DO_NOTHING: " + DO_NOTHING + "\nSS_external_call: " + SS_external_call);		// may be we have to do nothing		if (DO_NOTHING > 0) {			exit(0);		}		// prepare user selections		myselections_arefine = checkMySelection(true, true, "StoryScissors main");		//alert("myselections_arefine: " + myselections_arefine + "\nmyselections: " + myselections);		//alert(myselections[0].constructor.name);		if ((myselections == null) || (myselections[0] instanceof InsertionPoint) || (myselections[0] instanceof Character) || (myselections[0] instanceof Text)) {	// text cursor is within frame: we split at this position only, regardless of set 'splitAtParaName'			SS_settings.splitAtParaName = [""];		}		/**		 * evtl. show the main dialog or just shoot off		 */		//alert("SS_external_call: " + SS_external_call + "\nsplitAtParaName: " + SS_settings.splitAtParaName + "\nmyselections: " + myselections);		//if ((SS_settings.NO_MENU == 0) && ((myselections == null) || (SS_settings.splitAtParaName[0] == ""))) {		if (!SS_external_call) {			go = showMainDialog(true);			//alert("after showMainDialog go: " + go);			//if (go <= 0) return(1);		// ignore with 'palette'			return(SS_settings.totalParasSplitted);			//alert("SELECTED splitAtParaName: " + SS_settings.splitAtParaName);		}		else {			SS_isBusy = true;			var dialogEventsRemoved = removeDialogEventListeners("StoryScissors external");			myselections_arefine = checkMySelection(true, false, "StoryScissors external");			//alert("myselections_arefine: " + myselections_arefine);			if (myselections_arefine == 0) {				if (SS_settings.NO_MENU == 99) {					if (SS_wrk.dlgw != null) SS_wrk.dlgw.show();					else showMainDialog(false);	// open dialog only when requested				}				else if ( (SS_settings.NO_MENU == 1) && (SS_wrk.dlgw != null) ) showMainDialog(undefined,true);	//close dialog				//alert("myselections.length: " + myselections.length);				check_singleColumnsSplitter(true);				//alert("columns splitted: " + check_singleColumnsSplitter_count);				do_splitFrame();				// clean up				SS_settings.splitAtParaName = [""];			}			if (dialogEventsRemoved) addDialogEventListeners();			SS_isBusy = false;		}		if (save_SS_settings != null) {			restore_settings(save_SS_settings);	// restore original settings			save_SS_settings = null;		}		return(SS_settings.totalParasSplitted);	};	// propagate functions	this.main = main;	this.SS_settings = SS_settings;	this.restore_settings = restore_settings;	this.list_object = list_object;	this.Product = Product;};	// END StoryScissors()/** * Helper functions */list_object = function(obj, which, objname, nofuncs) {	if (typeof(obj) == 'undefined') return('undefined');	if (typeof(obj) == null) return('null');	var str = "",		numprops = 0, n = 0;	if ((typeof(objname) != 'undefined') && (objname != '')) str += objname + "={";	else str += "{";	for (var key in obj) numprops++;	for (var key in obj) {		if ((typeof(which) != 'undefined') && (which != '') && (key.toLowerCase().indexOf(which) < 0)) continue;		try {			if ( (obj[key].constructor.name == 'Function') && (typeof(nofuncs) != 'undefined') && (nofuncs == true) ) continue;			str += "\"" + key + "\":";			//alert (key + ": " + obj[key] + ": " + obj[key].constructor.name);			switch (obj[key].constructor.name) {				case 'Array':					var arr = obj[key];					str += "[";					for (var i = 0; i < arr.length; i++) {						str += (typeof(arr[i]) == 'string' ? "\"" : "") + arr[i] + (typeof(arr[i]) == 'string' ? "\"" : "");						if (i < (arr.length-1)) str += ",";					}					str += "]";					break;				case 'String':					 str += "\"" + obj[key] + "\"";					break;				case 'Point':					 str += "[" + obj[key][0] + "," + obj[key][1] + "]";					break;				case 'Function':					 str += "[" + obj[key][0] + "," + obj[key][1] + "]";					break;				default:	// Number					 str += obj[key];					 break;			}		} catch(ex){			str += "\"\"";		}		n++;		if (n < numprops) str += ",";	}	str += "}";	return(str);},save_settings = function (theset){	save_SS_settings = {};	for (var key in theset) save_SS_settings[key] = theset[key];},// return the number of splitted framesStoryScissors_getSettingsValue = function (which) {	if (typeof(SS_settings) == 'undefined') return(undefined);	return(SS_settings[which]);},// a function to get the return code of StoryScissors when called with doScript()StoryScissors_exitCode = function () {	return(SS_returncode);},StoryScissors_exception = function () {	if (SS_exception == null) return("");	return("ERROR name: " + SS_exception.name + "\nfileName: " + SS_exception.fileName + "\nmessage: " + SS_exception.message + "\nLine: " + SS_exception.line);};/**************************** * Main starter */// just DEBUG arguments/*var argsinfo = "";if (typeof(arguments) != 'undefined') {	argsinfo = typeof(arguments) + "\narguments constructor: " + arguments.constructor.name + "\narguments length: " + arguments.length + "\n\n" + arguments;}else argsinfo = "undefined";alert("arguments type: " + argsinfo);*/SS_returncode = 0; //reset return codeSS_exception = null;SS_reload = true;		// default = false. set to true to always load a new instance (reload the entire StoryScissors instance)//alert("Keys:\n " +  list_object(ScriptUI.environment.keyboardState));if ((typeof(SS_instance) == 'undefined') || (SS_reload == true)) {	//alert("defining SS_instance");	var SS_instance = null;}if ((typeof(arguments) != 'undefined') && (arguments.length > 0)) {	// is external call	//alert("typeof(arguments): " + typeof(arguments) + "\nnum arguments: " + arguments.length);	if (SS_isBusy) {		SS_exception = {name:"BUSY",fileName:"", message:"BUSY already, try later.",line:'undefined'};		SS_returncode = 99;	// already busy		//alert("BUSY");		exit(0);	}	SS_external_call = true;				// flag that we were called by an external parent script	//for (var i = 0; i < arguments.length; i++) alert("ARGUMENT ["+ i + "] = " + arguments[i]);	if (SS_instance == null) SS_instance = new StoryScissors();	save_settings(SS_instance.SS_settings);	// save settings	switch (arguments.length) {		case 0:			SS_returncode = SS_instance.main();			break;		case 1:			SS_returncode = SS_instance.main(arguments[0]);			break;		case 2:			var parts = arguments[1].split(","), key, value, i, argsObj = {}, pos;			for (i = 0; i < parts.length; i++) {				pos = parts[i].indexOf(":");				key = parts[i].substr(0,pos);				value = parts[i].substr(pos+1);				if ( (value.indexOf("'") == 0) || (value.indexOf("\"") == 0) ) {					value = value.replace("\"","");					value = value.replace("'","");				} 				else value = parseInt(value, 10);				//alert(key + "=" + value);				argsObj[key] = value;			}			try {				//alert("calling SS with: " + arguments[0] + "\nand:\n" + list_object(argsObj));				SS_returncode = SS_instance.main(arguments[0], argsObj);			}			catch(ex) {				SS_exception = ex;			}			break;	}	if (save_SS_settings != null) {		SS_instance.restore_settings(save_SS_settings);	// restore original settings		save_SS_settings = null;	}	// clear call arguments	//alert("A typeof(arguments): " + StoryScissors.list_object(arguments));	arguments = undefined;	//no effect: app.scriptArgs.clear();}else {		// open main dialog	//alert("(SS_instance == null): " + (SS_instance == null));	if (SS_instance == null) SS_instance = new StoryScissors();	try {		SS_returncode = SS_instance.main();	}	catch(ex) {		alert(ex.message + "\nLine: " + ex.line);	}}//alert("SS_instance: " + SS_instance.main);